{"remainingRequest":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/src/lib/TabNavigation.vue?vue&type=style&index=0&id=cef65154&lang=css","dependencies":[{"path":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/src/lib/TabNavigation.vue","mtime":1707210098283},{"path":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/css-loader/index.js","mtime":1707234519671},{"path":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1707234682978},{"path":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/postcss-loader/src/index.js","mtime":1707234519895},{"path":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/cache-loader/dist/cjs.js","mtime":1707234519865},{"path":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/vue-loader/lib/index.js","mtime":1707234682968}],"contextDependencies":[],"result":["\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.tab-nav {\n  width: 100%;\n  /*height needs to be set by containing element (outer container that holds this component)*/\n  height: 100%;\n  position: relative;\n  background-color: white;\n  overflow: hidden;\n}\n.tab-nav-arrow {\n  height: 100%;\n  width: 20px;\n  position: absolute;\n  top: 0px;\n  z-index: 10;\n}\n.tab-nav-arrow::after {\n  content: '';\n  position: absolute;\n  bottom: 0px;\n  left: 0px;\n  width: 100%;\n  height: 5px;\n  background-color: white;\n}\n.tab-nav-arrow.tn-left {\n  left: 0px;\n  background: linear-gradient(to right, rgba(255, 255, 255, 1) 0%, rgba(255, 255, 255, 1) 80%, rgba(255, 255, 255, 0) 100%);\n}\n.tab-nav-arrow.tn-right {\n  right: 0px;\n  background: linear-gradient(to right, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 1) 20%, rgba(255, 255, 255, 1) 100%);\n}\n.tab-nav-arrow img {\n  position: absolute;\n  height: 16px;\n  display: block;\n  top: 40%;\n  transform: translateY(-50%);\n  opacity: 0;\n  transition: opacity 0.3s ease;\n}\n.tab-nav-arrow.tn-right img {\n  right: 0px;\n}\n.tab-nav-arrow.tn-left img {\n  left: 0px;\n}\n.tab-nav-arrow.tn-active img {\n  opacity: 1;\n  cursor: pointer;\n}\n\n.tab-nav-cont {\n  /*can't use flex with flex-grow, because on page-load .tab-nav-cont doesn't take up full width,\n  only after 150ms it would. Use as normal block-div works,\n  but then the arrows need to use position absolute */\n  height: 100%;\n  margin: 0px;\n  position: relative;\n\n}\n.tab-nav-cont.tn-paginated {\n  margin: 0px 20px;\n}\n.tn-mask {\n  flex: none;\n  width: 10px;\n  align-self: stretch;\n  z-index: 2;\n  pointer-events: none;\n}\n.tn-mask-left {\n  background: linear-gradient(to right, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0));\n}\n.tn-mask-right {\n  background: linear-gradient(to right, rgba(255, 255, 255, 0), rgba(255, 255, 255, 1));\n}\n\n.tab-nav-holder {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  height: 100%;\n  display: flex;\n  align-items: center;\n  transition: transform 1s cubic-bezier(0.35, 0, 0.25, 1);\n}\n.tab-nav-holder.tn-inactive {\n  transition-duration: 0s;\n}\n\n",{"version":3,"sources":["TabNavigation.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"TabNavigation.vue","sourceRoot":"src/lib","sourcesContent":["<template>\n  <div class=\"tab-nav\" ref=\"tabnav\">\n\n    <div v-if=\"paginationNeeded\" ref=\"arrow\">\n      <div class=\"tab-nav-arrow tn-left\"\n        :class=\"{'tn-active': holderPos!==0}\" v-on:click=\"goBack\"\n      >\n        <img src=\"/img/arrow-left.svg\">\n      </div>\n      <div class=\"tab-nav-arrow tn-right\"\n        v-if=\"paginationNeeded\"\n        :class=\"{'tn-active': holderPos < holderWidth-containerWidth}\" v-on:click=\"goForward\"\n      >\n        <img src=\"/img/arrow-right.svg\">\n      </div>\n    </div>\n\n    <div class=\"tab-nav-cont\" ref=\"container\" :class=\"{'tn-paginated': paginationNeeded}\">\n\n      <div class=\"tab-nav-holder\" ref=\"holder\"\n        :class=\"{'tn-inactive': noTransition}\"\n        :style=\"{transform: 'translateX(-'+holderPos+'px)'}\"\n      >\n        <span v-for=\"(tab,index) in tabs\" ref=\"tab\" :key=\"tab.title\" class=\"tab-item\"\n          :class=\"{\n            selected:tabIndex===index,\n            'tn-left': tabIndex===index && isLeftDirection,\n            'tn-right': tabIndex===index && !isLeftDirection,\n          }\"\n          v-on:click=\"selectTab(index)\"\n        >\n          <div class=\"tab-item-title\">\n            <span>{{tab.title}}</span>\n            <span v-if=\"tabsWithWarnings.indexOf(tab.route) >= 0\" class=\"tab-item-warning\">!</span>\n          </div>\n        </span>\n      </div>\n\n    </div>\n\n  </div>\n</template>\n\n<script>\n// needs the outputsService for the tabsWithWarnings\nimport * as outputsService from '../outputsService.js';\n\nexport default {\n  name: 'TabNavigation',\n  props: ['tabs', 'tabIndex', 'callback'],\n  data() {\n    return {\n      paginationNeeded: undefined,\n      noTransition: true,\n      holderPos: undefined,\n      containerWidth: undefined,\n      holderWidth: undefined,\n      isLeftDirection: undefined,\n      tabsWithWarnings: outputsService.tabsWithWarnings\n    }\n  },\n  methods: {\n    selectTab(index) {\n      clearTimeout(this.panTimerId);\n\n      if(index < this.tabIndex) {\n        this.isLeftDirection = true;\n      } else {\n        this.isLeftDirection = false;\n      }\n\n      // check wether item is fully visible, if not make it fully visible\n      let item = this.tabItems[index];\n\n      // item was clicked, so no need to check weather it is inside the visible portion\n      if(item.left < this.holderPos) {\n        if(index === 0) {\n          this.holderPos = 0;\n        } else {\n          this.holderPos = item.left\n        }\n      }\n\n      if(item.right > this.holderPos + this.containerWidth) {\n        this.holderPos = item.right - this.containerWidth;\n      }\n\n      this.activeHolderPos = this.holderPos;\n      this.callback(index);\n\n    },\n    autoPanBack() {\n      clearTimeout(this.panTimerId);\n      this.panTimerId = setTimeout(() => {\n        this.holderPos = this.activeHolderPos;\n      }, 4000);\n    },\n    updateActiveHolderPos() {\n      // check if active item is still visible\n      let itemLeft = this.tabItems[this.tabIndex].left;\n      let itemRight = this.tabItems[this.tabIndex].right;\n      let holderLeft = this.holderPos;\n      let holderRight = this.holderPos + this.containerWidth;\n      if(\n          (itemLeft > holderLeft && itemLeft < holderRight) ||\n          (itemRight > holderLeft && itemRight < holderRight)\n        ) {\n            this.activeHolderPos = this.holderPos;\n      }\n    },\n    goBack() {\n      this.autoPanBack();\n\n      let newStartingItem;\n\n      // find first item, that starts on the left side of current portion\n      for(let i=this.tabItems.length-1; i >= 0; i--) {\n        if(this.tabItems[i].left < this.holderPos) {\n          newStartingItem = this.tabItems[i];\n          break;\n        }\n      }\n\n      if(!newStartingItem) {\n        return;\n      }\n\n      if(newStartingItem.right >= this.containerWidth) {\n        this.holderPos = newStartingItem.right-this.containerWidth;\n      } else {\n        this.holderPos = 0;\n      }\n\n      this.updateActiveHolderPos();\n    },\n    goForward() {\n      this.autoPanBack();\n      // find the next element which rightPosition is bigger than holderPos,\n      // make this elements leftPos the new holderPos if the remaining space is bigger than containerWidth\n      // if remaining space is smaller\n      let newStartingItem;\n\n      // Array.find() not supported by Internet Explorer\n      this.tabItems.some((item) => {\n         if(item.right > this.holderPos + this.containerWidth) {\n           newStartingItem = item;\n           return true;\n         }\n      });\n\n      if(!newStartingItem) {\n        return;\n      }\n\n      if(newStartingItem.remainingSpace >= this.containerWidth) {\n        this.holderPos = newStartingItem.left;\n      } else {\n        this.holderPos = this.holderWidth - this.containerWidth;\n      }\n\n      this.updateActiveHolderPos();\n    },\n    getPositions() {\n      this.tabItems = [];\n\n      if(this.$refs.container) {\n        this.containerWidth = this.$refs.container.getBoundingClientRect().width;\n      }\n\n      // if pagination is needed but the pagination-arrows are not rendered yet\n      if(!this.$refs.arrow && this.paginationNeeded) {\n        this.containerWidth -= this.paginationWidth;\n      }\n\n      let itemLeft = 0;\n      this.$refs.tab.forEach((tab, ind) => {\n        let itemWidth = tab.getBoundingClientRect().width;\n        let itemMarginLeft = parseInt(window.getComputedStyle(tab).getPropertyValue('margin-left'));\n        let itemMarginRight = parseInt(window.getComputedStyle(tab).getPropertyValue('margin-right'));\n\n        itemWidth += itemMarginLeft + itemMarginRight;\n\n        this.tabItems.push({\n          left: itemLeft,\n          width: itemWidth,\n          right: itemLeft + itemWidth,\n          title: this.tabs[ind].title,\n          remainingSpace: this.holderWidth - itemLeft\n        });\n        itemLeft += itemWidth;\n      });\n    },\n    findPosOfActiveTab() {\n\n      // go find in which portion the activeTab starts\n      // if it ends in the next portion add the difference in px\n\n      // check if activeTab is fully inside one portion\n      let numPortions = Math.ceil(this.holderWidth / this.containerWidth);\n      let leftOfActive = this.tabItems[this.tabIndex].left;\n      let rightOfActive = this.tabItems[this.tabIndex].right;\n\n      for(let i=1; i<=numPortions; i++) {\n        if(leftOfActive < this.containerWidth*i) {\n          if(i<numPortions) {\n            this.holderPos = this.containerWidth*(i-1);\n            // before last Portion, overlap possible\n            if(rightOfActive > this.containerWidth*i) {\n              // if active Element overlaps its portion, add the overlap to the holderPos\n              this.holderPos += rightOfActive - this.containerWidth*i;\n            }\n          }\n          if(i === numPortions) {\n            // last Portion, no overlap possible\n            // the last portion can be smaller than the containerWidth, so this assignment is safe:\n            this.holderPos = this.holderWidth - this.containerWidth;\n          }\n\n          break;\n        }\n      }\n\n      this.activeHolderPos = this.holderPos;\n\n    },\n    checkPagination() {\n      this.paginationNeeded = false;\n      if(this.$refs.holder) {\n        this.holderWidth = this.$refs.holder.getBoundingClientRect().width;\n      }\n      if(this.$refs.tabnav.getBoundingClientRect().width < this.holderWidth) {\n        this.paginationNeeded = true;\n      }\n    },\n    showTabs() {\n      window.requestAnimationFrame(() => {\n        window.requestAnimationFrame(() => {\n          this.noTransition = false;\n        });\n      });\n    },\n    redraw() {\n      // only redraw when resizing is complete, not on every single resize event\n      clearTimeout(this.timerId);\n      this.timerId = setTimeout(() => {\n        this.checkPagination();\n        if(this.paginationNeeded) {\n          this.getPositions();\n          this.findPosOfActiveTab();\n        } else {\n          // reset to beginning if no pagination needed\n          this.holderPos = 0;\n          this.getPositions();\n        }\n      }, 100);\n    }\n  },\n  created() {\n    // needed for automatically panning back after inactivity after scrolling\n    this.activeHolderPos = undefined;\n\n    this.panTimerId = undefined;\n\n    // hardcoded, well..\n    this.paginationWidth = 40;\n\n    this.timerId = undefined;\n    window.addEventListener('resize', this.redraw);\n  },\n  mounted() {\n    this.checkPagination();\n    this.getPositions();\n    this.findPosOfActiveTab();\n    this.showTabs();\n  },\n  beforeDestroy() {\n    window.removeEventListener('resize', this.redraw);\n  }\n}\n</script>\n\n<style>\n.tab-nav {\n  width: 100%;\n  /*height needs to be set by containing element (outer container that holds this component)*/\n  height: 100%;\n  position: relative;\n  background-color: white;\n  overflow: hidden;\n}\n.tab-nav-arrow {\n  height: 100%;\n  width: 20px;\n  position: absolute;\n  top: 0px;\n  z-index: 10;\n}\n.tab-nav-arrow::after {\n  content: '';\n  position: absolute;\n  bottom: 0px;\n  left: 0px;\n  width: 100%;\n  height: 5px;\n  background-color: white;\n}\n.tab-nav-arrow.tn-left {\n  left: 0px;\n  background: linear-gradient(to right, rgba(255, 255, 255, 1) 0%, rgba(255, 255, 255, 1) 80%, rgba(255, 255, 255, 0) 100%);\n}\n.tab-nav-arrow.tn-right {\n  right: 0px;\n  background: linear-gradient(to right, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 1) 20%, rgba(255, 255, 255, 1) 100%);\n}\n.tab-nav-arrow img {\n  position: absolute;\n  height: 16px;\n  display: block;\n  top: 40%;\n  transform: translateY(-50%);\n  opacity: 0;\n  transition: opacity 0.3s ease;\n}\n.tab-nav-arrow.tn-right img {\n  right: 0px;\n}\n.tab-nav-arrow.tn-left img {\n  left: 0px;\n}\n.tab-nav-arrow.tn-active img {\n  opacity: 1;\n  cursor: pointer;\n}\n\n.tab-nav-cont {\n  /*can't use flex with flex-grow, because on page-load .tab-nav-cont doesn't take up full width,\n  only after 150ms it would. Use as normal block-div works,\n  but then the arrows need to use position absolute */\n  height: 100%;\n  margin: 0px;\n  position: relative;\n\n}\n.tab-nav-cont.tn-paginated {\n  margin: 0px 20px;\n}\n.tn-mask {\n  flex: none;\n  width: 10px;\n  align-self: stretch;\n  z-index: 2;\n  pointer-events: none;\n}\n.tn-mask-left {\n  background: linear-gradient(to right, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0));\n}\n.tn-mask-right {\n  background: linear-gradient(to right, rgba(255, 255, 255, 0), rgba(255, 255, 255, 1));\n}\n\n.tab-nav-holder {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  height: 100%;\n  display: flex;\n  align-items: center;\n  transition: transform 1s cubic-bezier(0.35, 0, 0.25, 1);\n}\n.tab-nav-holder.tn-inactive {\n  transition-duration: 0s;\n}\n\n</style>\n"]}]}