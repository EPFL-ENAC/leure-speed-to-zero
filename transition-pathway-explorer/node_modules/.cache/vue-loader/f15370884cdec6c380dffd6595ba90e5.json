{"remainingRequest":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/src/components/Outputs.vue?vue&type=script&lang=js","dependencies":[{"path":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/src/components/Outputs.vue","mtime":1707210098268},{"path":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/cache-loader/dist/cjs.js","mtime":1707234519865},{"path":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/babel-loader/lib/index.js","mtime":1707234519797},{"path":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/cache-loader/dist/cjs.js","mtime":1707234519865},{"path":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/vue-loader/lib/index.js","mtime":1707234682968}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport * as dataService from '../dataService.js';\nimport * as outputsService from '../outputsService.js';\nimport * as inputsService from '../inputsService.js';\n\nimport APIStatusDialog from './APIStatusDialog.vue';\nimport TabNavigation from '../lib/TabNavigation.vue';\nimport DropDown from '../lib/DropDown.vue';\nimport PopUp from '../lib/PopUp.vue';\n\nexport default {\n  name: 'Outputs',\n  components: {\n    //generic subtabs\n    'OneChart': () => import('./tabs/OneChart.vue'),\n    'TwoCharts': () => import('./tabs/TwoCharts.vue'),\n\n    //specific subtabs\n    'EmissionsByCountry': () => import('./tabs/emissions/EmissionsByCountry.vue'),\n    'GHGSources': () => import('./tabs/emissions/GHGSources.vue'),\n    'WaterStressMap': () => import('./tabs/water/WaterStressMap.vue'),\n    'MineralAvailability': () => import('./tabs/materials/MineralAvailability.vue'),\n    'ClimateImpactChart': () => import('./tabs/ClimateImpactChart.vue'),\n    // 'EnergyFlows': () => import('./tabs/energyflows/EnergyFlows.vue'),\n    'ChangePerSector': () => import('./tabs/employment/ChangePerSector.vue'),\n    'EmploymentChange': () => import('./tabs/employment/EmploymentChange.vue'),\n    'WagesPerSkill': () => import('./tabs/employment/WagesPerSkill.vue'),\n    'SectoralTrade': () => import('./tabs/world/SectoralTrade.vue'),\n    'EuRowTrade': () => import('./tabs/world/EuRowTrade.vue'),\n    'TradeComposition': () => import('./tabs/world/TradeComposition.vue'),\n\n    APIStatusDialog,\n    'APIStatusDialogMobile': () => import('./APIStatusDialogMobile.vue'),\n    TabNavigation,\n    DropDown,\n    PopUp\n  },\n  props: ['appState'],\n  data() {\n    return {\n      numTabs: outputsService.tabs.length,\n      missingOutputs: [],\n      selected: inputsService.selected, // reactive, can be changed in Inputs.vue, changes need to be reactive here! There are other ways to achieve this, but this is cheap\n      warningsInfos: outputsService.warningsInfos, // reactive because async import and Vue.set() for initialisation, doesn't work as computed property\n      warnings: outputsService.warnings, // current warnings, reactive because easy\n      tabWarnings: [], // holds warnings for the current tab\n      warningOpen: false\n    }\n  },\n  created() {\n    this.outputs = outputsService.outputs;\n    this.tabs = outputsService.tabs;\n    this.chartDefinitions = outputsService.chartDefinitions;\n  },\n  computed: {\n    selTab() {\n      return outputsService.tabs[this.appState.activeTab];\n    },\n    chartComponent() {\n      // returns the name of the component of the first chart of a subtab (usually there also is only one chart)\n      return this.tabs[this.appState.activeTab].subtabs[this.appState.activeSubtab].component;\n    },\n    subtab() {\n      return this.tabs[this.appState.activeTab].subtabs[this.appState.activeSubtab];\n    },\n    zoomableCountries() {\n      let chartComp = this.chartComponent;\n      if(outputsService.zoomableComponents.indexOf(chartComp) >= 0) {\n        return inputsService.selected; //reference is fine\n      } else {\n        return [inputsService.selected[0]];\n      }\n    },\n    countryIndex() {\n      // only return the countryZoomIndex if it is supported, return 0 by default\n\n      // important, this.appState.countryZoomIndex needs to be accessed the first time this computed property initialises,\n      // because it is reactive and only on init the vue internal reactive mapping is set\n      let countryIndex = this.appState.countryZoomIndex;\n\n      if(this.zoomableCountries.length < 2 || this.subtab.countryZoomDisabled) {\n        return 0;\n      } else {\n        return countryIndex;\n      }\n    }\n  },\n  methods: {\n    getLeverName(leverId) {\n      return inputsService.levers[leverId] ? inputsService.levers[leverId].title : '';\n    },\n    toggleWarning() {\n      this.warningOpen = !this.warningOpen;\n      if(this.warningOpen) {\n        this.getLeversWithWarnings();\n      } else {\n        this.emptyLeversWithWarnings();\n      }\n    },\n    closeWarning() {\n      this.warningOpen = false;\n      this.emptyLeversWithWarnings();\n    },\n    emptyLeversWithWarnings() {\n      inputsService.resetHighlightedLevers();\n    },\n    getLeversWithWarnings() {\n      if(!this.warningsInfos) {\n        return;\n      }\n      Object.keys(outputsService.warnings).forEach((warningId)=> {\n        if(this.warningsInfos[warningId] && this.warningsInfos[warningId].tabs.indexOf(this.selTab.route) >= 0) {\n          if(this.warningsInfos[warningId].levers && this.warningsInfos[warningId].levers.length) {\n            inputsService.addToHighlightedLevers(this.warningsInfos[warningId].levers);\n          }\n        }\n      });\n    },\n    getTabWarnings() {\n      this.tabWarnings = [];\n      // assigning a new reference doesn't kill the reactivity, at least not inside a component, hm\n\n      if(!this.warningsInfos) {\n        return;\n      }\n\n      Object.keys(outputsService.warnings).forEach((warningId)=> {\n        if(this.warningsInfos[warningId] && this.warningsInfos[warningId].tabs.indexOf(this.selTab.route) >= 0) {\n          this.tabWarnings.push(warningId);\n        }\n      });\n    },\n    selectTab(ind) {\n      if(ind === this.appState.activeTab) {\n        return;\n      }\n\n      // make the warning div disappear as soon as user switches tab\n      // it will be reevaluated as soon as the new APIResponse is there (see watches)\n      this.tabWarnings = [];\n      this.closeWarning();\n\n      outputsService.selectTab(ind, 0, true);\n      this.correctCountryZoomIndex();\n      dataService.fetchData();\n      this.missingOutputs = []; // necessary, otherwise old missing inputs are shown on tabChange before api-response is there\n      // console.log('selectTab ', this.selected[this.appState.countryZoomIndex].id);\n    },\n    selectSubTab(ind) {\n      outputsService.selectSubTab(ind, true);\n      this.getMissingOutputs();\n    },\n    selectSubTab2(item,ind) {\n      outputsService.selectSubTab(ind, true);\n      this.correctCountryZoomIndex();\n      this.getMissingOutputs();\n    },\n    setCountryZoom(item,ind) {\n      outputsService.setCountryZoom(ind);\n    },\n    correctCountryZoomIndex() {\n      // not ideal yet, not very generic\n      if(this.zoomableCountries.length < 2 || this.subtab.countryZoomDisabled) {\n        outputsService.setCountryZoom(0);\n      }\n    },\n    getMissingOutputs() {\n      this.missingOutputs = [];\n      this.subtab.charts.forEach((chartId)=> {\n        this.chartDefinitions[this.appState.activeTab][chartId].outputs.forEach((reqOutp) => {\n          if(!this.outputs[reqOutp.id] || !this.outputs[reqOutp.id].data) {\n            this.missingOutputs.push(reqOutp.id);\n          }\n        });\n      });\n    }\n  },\n  watch: {\n    'appState.lastAPIResponse': function() {\n\n      this.getMissingOutputs();\n      this.getTabWarnings();\n\n      // this.appState.lastAPIAction doesn't change on successive country changes,\n      // so a watch on lastAPIAction won't trigger on every change, that's why it's included in this watch\n      if(this.appState.lastAPIAction.indexOf('countryChange') >= 0) {\n        if(this.zoomableCountries.length > 1) {\n          outputsService.setCountryZoom(1);\n        } else {\n          outputsService.setCountryZoom(0);\n        }\n        // still need to correct if countryZoom is disabled or not supported by the current subtab\n        this.correctCountryZoomIndex();\n\n      }\n      // console.log('lastAPIResponse changed ', this.appState.countryZoomIndex);\n    }\n  },\n  mounted() {\n    this.getTabWarnings();\n    window.scroll(0, 0);\n  }\n}\n",{"version":3,"sources":["Outputs.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2FA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Outputs.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div id=\"charts-container\" ref=\"container\">\n    <div id=\"charts-header\" class=\"noselect\">\n      <TabNavigation\n        :tabs=\"tabs\" :tab-index=\"appState.activeTab\" :callback=\"selectTab\"\n      />\n    </div>\n    <div v-if=\"tabWarnings.length\" id=\"warnings-container\">\n      <img id=\"warning-icon\" src=\"/img/warning-sharp.svg\" tabindex=\"1\"\n        v-on:click=\"toggleWarning\"\n        v-on:keyup.enter=\"toggleWarning\"\n      >\n      <PopUp id=\"warning-popup\" :is-open=\"warningOpen\" :closing-callback=\"closeWarning\" ref=\"popup\" exception-id=\"warning-icon\">\n        <div id=\"warning-content\">\n          <div v-for=\"warningId in tabWarnings\" class=\"warning\" :key=\"warningId\">\n            <div class=\"warning-description\">{{warningsInfos[warningId][warnings[warningId]]}}</div>\n            <div class=\"warning-levers-container\"\n              v-if=\"warningsInfos[warningId].levers && warningsInfos[warningId].levers.length\"\n            >\n              <div>Levers that have the biggest influence on this issue are highlighted in the levers table, they are:</div>\n              <ul class=\"warning-levers\">\n                <li v-for=\"leverid in warningsInfos[warningId].levers\" v-if=\"getLeverName(leverid)\" :key=\"leverid\">\n                  {{getLeverName(leverid)}}\n                </li>\n              </ul>\n            </div>\n          </div>\n        </div>\n      </PopUp>\n    </div>\n\n    <div id=\"charts-subheader\">\n\n      <!--\n        The key is important, otherwise on a tab-change the dropdown doesn't fully update\n        The key should be the appState.activeTab, not the appState.activeSubtab,\n        because the subtab-selection-dropdown should remain the same element across all subtabs\n     -->\n      <DropDown class=\"dropdown-select\" :items=\"selTab.subtabs\" name-prop=\"title\" :key=\"appState.activeTab\"\n        :callback=\"selectSubTab2\" :selected=\"appState.activeSubtab\"\n      />\n\n      <!--\n          This dropdown depends on each subtab, so the key should be the appState.activeSubtab,\n          Without the '+z', vue complains about duplicate keys,\n          because the appState.activeTab (key for dropdown above) and the appState.activeSubtab\n          can take on the same integer values\n      -->\n      <DropDown v-if=\"selected.length > 1\" class=\"dropdown-select\" :items=\"zoomableCountries\" name-prop=\"name\"\n        :callback=\"setCountryZoom\" :selected=\"countryIndex\" :key=\"appState.activeSubtab+'z'\"\n        :disabled=\"subtab.countryZoomDisabled\"\n      />\n\n    </div>\n    <div id=\"charts-main\" :class=\"{'first-tab-opened':appState.activeTab===0}\">\n\n     <APIStatusDialog v-if=\"!appState.isMobile\" :app-state=\"appState\"/>\n     <APIStatusDialogMobile v-if=\"appState.isMobile\" :app-state=\"appState\"/>\n\n      <div id=\"output\">\n        <div id=\"missing-data\" v-if=\"missingOutputs.length && appState.showMissingOutputs\">\n          <h4>requested data not found:</h4>\n          <div v-for=\"item in missingOutputs\" :key=\"item\">\n            {{item}}\n          </div>\n        </div>\n        <div class=\"subtab-container\">\n          <!--\n            v-if=\"appState.userAction.indexOf('tabChange') < 0\" necessary, so component immediately disappears on a tab-change\n\n            :key=\"subtab.title\" is very important, because:\n            if two subtabs share the same component, and the user toggles between them,\n            the component only remounts when they have different keys\n\n            loading chart-component with :is, depending on tab/subtab\n            makes them load asynchronuously (lazy) on demand\n            Optional: show a loading-animation when tab data is being fetched\n          -->\n          <component v-bind:is=\"chartComponent\" v-if=\"appState.userAction.indexOf('tabChange') < 0\"\n            :outputs=\"outputs\" :subtab=\"subtab\" :chart-definitions=\"chartDefinitions[appState.activeTab]\"\n            :app-state=\"appState\"\n            :countrycode=\"selected[countryIndex].id\"\n            :key=\"subtab.title\"\n          ></component>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport * as dataService from '../dataService.js';\nimport * as outputsService from '../outputsService.js';\nimport * as inputsService from '../inputsService.js';\n\nimport APIStatusDialog from './APIStatusDialog.vue';\nimport TabNavigation from '../lib/TabNavigation.vue';\nimport DropDown from '../lib/DropDown.vue';\nimport PopUp from '../lib/PopUp.vue';\n\nexport default {\n  name: 'Outputs',\n  components: {\n    //generic subtabs\n    'OneChart': () => import('./tabs/OneChart.vue'),\n    'TwoCharts': () => import('./tabs/TwoCharts.vue'),\n\n    //specific subtabs\n    'EmissionsByCountry': () => import('./tabs/emissions/EmissionsByCountry.vue'),\n    'GHGSources': () => import('./tabs/emissions/GHGSources.vue'),\n    'WaterStressMap': () => import('./tabs/water/WaterStressMap.vue'),\n    'MineralAvailability': () => import('./tabs/materials/MineralAvailability.vue'),\n    'ClimateImpactChart': () => import('./tabs/ClimateImpactChart.vue'),\n    // 'EnergyFlows': () => import('./tabs/energyflows/EnergyFlows.vue'),\n    'ChangePerSector': () => import('./tabs/employment/ChangePerSector.vue'),\n    'EmploymentChange': () => import('./tabs/employment/EmploymentChange.vue'),\n    'WagesPerSkill': () => import('./tabs/employment/WagesPerSkill.vue'),\n    'SectoralTrade': () => import('./tabs/world/SectoralTrade.vue'),\n    'EuRowTrade': () => import('./tabs/world/EuRowTrade.vue'),\n    'TradeComposition': () => import('./tabs/world/TradeComposition.vue'),\n\n    APIStatusDialog,\n    'APIStatusDialogMobile': () => import('./APIStatusDialogMobile.vue'),\n    TabNavigation,\n    DropDown,\n    PopUp\n  },\n  props: ['appState'],\n  data() {\n    return {\n      numTabs: outputsService.tabs.length,\n      missingOutputs: [],\n      selected: inputsService.selected, // reactive, can be changed in Inputs.vue, changes need to be reactive here! There are other ways to achieve this, but this is cheap\n      warningsInfos: outputsService.warningsInfos, // reactive because async import and Vue.set() for initialisation, doesn't work as computed property\n      warnings: outputsService.warnings, // current warnings, reactive because easy\n      tabWarnings: [], // holds warnings for the current tab\n      warningOpen: false\n    }\n  },\n  created() {\n    this.outputs = outputsService.outputs;\n    this.tabs = outputsService.tabs;\n    this.chartDefinitions = outputsService.chartDefinitions;\n  },\n  computed: {\n    selTab() {\n      return outputsService.tabs[this.appState.activeTab];\n    },\n    chartComponent() {\n      // returns the name of the component of the first chart of a subtab (usually there also is only one chart)\n      return this.tabs[this.appState.activeTab].subtabs[this.appState.activeSubtab].component;\n    },\n    subtab() {\n      return this.tabs[this.appState.activeTab].subtabs[this.appState.activeSubtab];\n    },\n    zoomableCountries() {\n      let chartComp = this.chartComponent;\n      if(outputsService.zoomableComponents.indexOf(chartComp) >= 0) {\n        return inputsService.selected; //reference is fine\n      } else {\n        return [inputsService.selected[0]];\n      }\n    },\n    countryIndex() {\n      // only return the countryZoomIndex if it is supported, return 0 by default\n\n      // important, this.appState.countryZoomIndex needs to be accessed the first time this computed property initialises,\n      // because it is reactive and only on init the vue internal reactive mapping is set\n      let countryIndex = this.appState.countryZoomIndex;\n\n      if(this.zoomableCountries.length < 2 || this.subtab.countryZoomDisabled) {\n        return 0;\n      } else {\n        return countryIndex;\n      }\n    }\n  },\n  methods: {\n    getLeverName(leverId) {\n      return inputsService.levers[leverId] ? inputsService.levers[leverId].title : '';\n    },\n    toggleWarning() {\n      this.warningOpen = !this.warningOpen;\n      if(this.warningOpen) {\n        this.getLeversWithWarnings();\n      } else {\n        this.emptyLeversWithWarnings();\n      }\n    },\n    closeWarning() {\n      this.warningOpen = false;\n      this.emptyLeversWithWarnings();\n    },\n    emptyLeversWithWarnings() {\n      inputsService.resetHighlightedLevers();\n    },\n    getLeversWithWarnings() {\n      if(!this.warningsInfos) {\n        return;\n      }\n      Object.keys(outputsService.warnings).forEach((warningId)=> {\n        if(this.warningsInfos[warningId] && this.warningsInfos[warningId].tabs.indexOf(this.selTab.route) >= 0) {\n          if(this.warningsInfos[warningId].levers && this.warningsInfos[warningId].levers.length) {\n            inputsService.addToHighlightedLevers(this.warningsInfos[warningId].levers);\n          }\n        }\n      });\n    },\n    getTabWarnings() {\n      this.tabWarnings = [];\n      // assigning a new reference doesn't kill the reactivity, at least not inside a component, hm\n\n      if(!this.warningsInfos) {\n        return;\n      }\n\n      Object.keys(outputsService.warnings).forEach((warningId)=> {\n        if(this.warningsInfos[warningId] && this.warningsInfos[warningId].tabs.indexOf(this.selTab.route) >= 0) {\n          this.tabWarnings.push(warningId);\n        }\n      });\n    },\n    selectTab(ind) {\n      if(ind === this.appState.activeTab) {\n        return;\n      }\n\n      // make the warning div disappear as soon as user switches tab\n      // it will be reevaluated as soon as the new APIResponse is there (see watches)\n      this.tabWarnings = [];\n      this.closeWarning();\n\n      outputsService.selectTab(ind, 0, true);\n      this.correctCountryZoomIndex();\n      dataService.fetchData();\n      this.missingOutputs = []; // necessary, otherwise old missing inputs are shown on tabChange before api-response is there\n      // console.log('selectTab ', this.selected[this.appState.countryZoomIndex].id);\n    },\n    selectSubTab(ind) {\n      outputsService.selectSubTab(ind, true);\n      this.getMissingOutputs();\n    },\n    selectSubTab2(item,ind) {\n      outputsService.selectSubTab(ind, true);\n      this.correctCountryZoomIndex();\n      this.getMissingOutputs();\n    },\n    setCountryZoom(item,ind) {\n      outputsService.setCountryZoom(ind);\n    },\n    correctCountryZoomIndex() {\n      // not ideal yet, not very generic\n      if(this.zoomableCountries.length < 2 || this.subtab.countryZoomDisabled) {\n        outputsService.setCountryZoom(0);\n      }\n    },\n    getMissingOutputs() {\n      this.missingOutputs = [];\n      this.subtab.charts.forEach((chartId)=> {\n        this.chartDefinitions[this.appState.activeTab][chartId].outputs.forEach((reqOutp) => {\n          if(!this.outputs[reqOutp.id] || !this.outputs[reqOutp.id].data) {\n            this.missingOutputs.push(reqOutp.id);\n          }\n        });\n      });\n    }\n  },\n  watch: {\n    'appState.lastAPIResponse': function() {\n\n      this.getMissingOutputs();\n      this.getTabWarnings();\n\n      // this.appState.lastAPIAction doesn't change on successive country changes,\n      // so a watch on lastAPIAction won't trigger on every change, that's why it's included in this watch\n      if(this.appState.lastAPIAction.indexOf('countryChange') >= 0) {\n        if(this.zoomableCountries.length > 1) {\n          outputsService.setCountryZoom(1);\n        } else {\n          outputsService.setCountryZoom(0);\n        }\n        // still need to correct if countryZoom is disabled or not supported by the current subtab\n        this.correctCountryZoomIndex();\n\n      }\n      // console.log('lastAPIResponse changed ', this.appState.countryZoomIndex);\n    }\n  },\n  mounted() {\n    this.getTabWarnings();\n    window.scroll(0, 0);\n  }\n}\n</script>\n\n<style>\n#charts-container {\n  flex-grow: 1;\n  display: flex;\n  flex-direction: column;\n  background-color: white;\n  padding: 0px 0px 0px 40px;\n  box-shadow: 0px 0px 5px 0px rgba(0,0,0,0.3);\n}\n#charts-header {\n  flex: none;\n  height: 31px;\n  margin-top: 21px;\n  display: flex;\n  align-items: stretch;\n  padding-right: 40px;\n  position: relative;\n}\n.tab-nav-holder {\n  border-bottom: 2px solid #e2e2e2;\n  box-sizing: border-box;\n}\n.tab-item {\n  margin: 0px 5px;\n  height: 100%;\n  box-sizing: border-box;\n  color: #8c8a8c;\n  cursor: pointer;\n  font-size: 18px;\n  white-space: nowrap;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transition: color 0.3s ease;\n  position: relative;\n}\n.tab-item:first-child {\n  margin-left: 0px;\n}\n.tab-item:last-child {\n  margin-right: 0px;\n}\n.tab-item-title {\n  height: 100%;\n  display: flex;\n  align-items: center;\n  position: relative;\n  margin: 0px 3px;   /*use padding if underline needs to be broader than text */\n  padding-bottom: 8px;\n  box-sizing: border-box;\n}\n.tab-item-title:first-child {\n  margin-left: 0px;\n}\n.tab-item-title:last-child {\n  margin-right: 0px;\n}\n.tab-item-warning {\n  position: absolute;\n  height: 100%;\n  top: 0px;\n  right: -6px;\n  color: #ff0000;\n}\n.tab-item.selected {\n  color: black;\n}\n.tab-item-title::after {\n  content: '';\n  position: absolute;\n  bottom: -2px;\n  left: 0px;\n  z-index: 100;\n  width: 100%;\n  height: 2px;\n  background-color: black;\n  transform: scaleX(0);\n}\n.tab-item.tn-left .tab-item-title::after {\n  transform-origin: left;\n}\n.tab-item.tn-right .tab-item-title::after {\n  transform-origin: left;\n}\n.tab-item.selected .tab-item-title::after {\n  transform: scaleX(1);\n  transition: transform 0.3s ease;\n}\n\n#charts-main {\n  display: flex;\n  flex-direction: column;\n  background-color: white;\n  flex-grow: 1;\n  position: relative;\n\n  /*\n    necessary, otherwise the outputs even though having overflow:auto will\n    be taller than the available space, resulting in a scrollbar on body\n    https://medium.com/@stephenbunch/how-to-make-a-scrollable-container-with-dynamic-height-using-flexbox-5914a26ae336\n  */\n  min-height: 0px;\n}\n#charts-main.first-tab-opened {\n  border-top-left-radius: 0px;\n}\n\n#subtab-cont {\n  margin: 10px;\n  position: relative;\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: space-between;\n  color: grey;\n  border-top: 1px solid lightgrey;\n  border-left: 1px solid lightgrey;\n}\n#subtab-cont:before {\n  content: '';\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  height: 100%;\n  width: 1px;\n  background-color: lightgrey;\n}\n#subtab-cont:after {\n  content: '';\n  position: absolute;\n  bottom: 0px;\n  left: 0px;\n  width: 100%;\n  height: 1px;\n  background-color: lightgrey;\n}\n.subtab-item {\n  margin: 0px;\n  padding: 4px;\n  background-color: white;\n  font-size: 16px;\n  cursor: pointer;\n  white-space: nowrap;\n  flex-grow: 1;\n  text-align: center;\n  border-right: 1px solid lightgrey;\n  border-bottom: 1px solid lightgrey;\n\n}\n.subtab-item.selected {\n  background-color: #35a0cd;\n  background-color: lightgrey;\n}\n\n/*subtabs-----------------------------------*/\n.dropdown-select {\n  position: relative;\n  /*DropDown is inline-block by default and can have overflow:hidden, that's why vertical align-bottom might be necessary*/\n  vertical-align: bottom;\n  z-index: 100;\n  margin-top: 10px;\n  cursor: pointer;\n  margin-left: 20px;\n}\n.dropdown-select.drop-down.dd-open {\n  /* box-shadow: 0px 2px 4px 0px rgba(0,0,0,0.5); */\n}\n.dropdown-select:focus {\n  outline: none;\n}\n.dropdown-select:focus .drop-down-icon-path:not(.dd-disabled) {\n  stroke: #27aae1 !important;\n  fill: #27aae1 !important;\n}\n.dropdown-select .drop-down-head {\n  padding: 4px 20px 4px 4px;\n  border-radius: 1px;\n}\n.dropdown-select .drop-down-head span {\n  font-size: 16px;\n  color: black;\n}\n.dropdown-select .drop-down-items-container {\n  border-top: 1px solid #aeadae;\n  box-shadow: 0px 0px 4px 0px rgba(0,0,0,0.5);\n  background-color: #e4e4e4;\n  max-height: 350px;\n}\n.dropdown-select .drop-down-item {\n  padding: 5px 20px 5px 5px;\n}\n\n.dropdown-select .drop-down-item:hover {\n  background-color: #eeeeee;\n}\n.dropdown-select .drop-down-item.dd-selected {\n  background-color: #cccccc;\n}\n\n\n#output {\n  flex-grow: 1;\n  flex-shrink: 1000;\n  position: relative;\n  overflow: hidden;\n  display: flex;\n  flex-direction: column;\n}\n\n#missing-data {\n  width: 95%;\n  margin: 10px auto;\n  font-size: 16px;\n}\n#missing-data h4 {\n  margin: 0px;\n  margin-bottom: 5px;\n}\n.subtab-container {\n  flex-grow: 1;\n  overflow: hidden;\n}\n\n/*inside output-component*/\n.subtab-content {\n  width: 100%;\n  margin: 0px auto;\n  padding-top: 30px;\n\n  box-sizing: border-box;\n  height: 100%;\n  overflow: auto;\n}\n\n.subtab-content h2 {\n  text-align: center;\n}\n\n/*Charts*/\n.chart-container {\n  height: 96%;\n  width: 96%;\n  position: relative;\n}\n.chart {\n  height: 100%;\n  width: 100%;\n  position: absolute;\n  top: 0px;\n  left: 0px;\n}\n#warnings-container {\n  height: 0px;\n  width: 96%; /*same as charts*/\n  position: relative;\n}\n#warning-icon {\n  position: absolute;\n  right: 0px;\n  top: 5px;\n  display: block;\n  height: 20px;\n  cursor: pointer;\n  z-index: 10;\n}\n#warning-popup {\n  position: absolute;\n  top: 30px;\n  right: 0px;\n  width: 100%;\n  max-width: 500px;\n  max-height: 300px;\n  z-index: 101;\n  box-shadow: 1px 1px 3px 0px rgba(0,0,0,0.5);\n}\n#warning-content {\n  padding: 10px;\n  max-height: 260px;\n  overflow-y: auto;\n  background-color: #ffd8d8;\n  border: 2px solid #ff0000;\n}\n.warning-description {\n  font-weight: bold;\n}\n.warning-levers-container {\n  margin-top: 10px;\n  padding-left: 20px;\n}\n.warning-levers {\n  margin: 15px 10px 5px 10px;\n}\n</style>\n"]}]}