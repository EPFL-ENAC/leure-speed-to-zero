{"remainingRequest":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/babel-loader/lib/index.js!/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/eslint-loader/index.js??ref--13-0!/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/src/chartSeriesBuilders.js","dependencies":[{"path":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/src/chartSeriesBuilders.js","mtime":1707210098267},{"path":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/cache-loader/dist/cjs.js","mtime":1707234519865},{"path":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/babel-loader/lib/index.js","mtime":1707234519797},{"path":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/eslint-loader/index.js","mtime":1707234519720}],"contextDependencies":[],"result":["import \"core-js/modules/es7.object.get-own-property-descriptors\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es6.function.name\";\nimport _defineProperty from \"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport \"core-js/modules/es6.math.sign\";\nimport \"core-js/modules/es6.array.sort\";\nimport \"core-js/modules/es6.array.find\";\nimport _slicedToArray from \"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport \"core-js/modules/web.dom.iterable\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// TODO:\n// restructure this module for more readability\n// findNullstellen should only accept a single series and only require the series with x and y values as a single parameter\nexport function buildChartData(countryCode, chartDef, outputs, withNegative) {\n  var timeAxis;\n  var series = [];\n  var totalData = []; // chartDef.outputs only contains the keys (strings) used in outputs\n\n  chartDef.outputs.forEach(function (outp) {\n    // skip custom outputs\n    if (outp.custom) {\n      return;\n    } // outputs[outp] might exist (created from frontend config file),\n    // but outputs[outp].data or outputs[outp].timeAxis might not exist (if this output is unknown to the API)\n    // if an output is unknown to API and it wasn't listed in the Outputs config constant, then outputs[outp] is undefined\n    // outputs that are not listed in the Outputs config constant only get initialized into outputs on a succesful API fetch\n\n\n    if (!outputs[outp.id] || !outputs[outp.id].data) {\n      return;\n    }\n\n    if (!timeAxis) {\n      // outp.timeAxis can still be undefined (if output is unknown to API),\n      // but then it is looked for one on the next iteration\n      timeAxis = outputs[outp.id].timeAxis;\n    }\n\n    if (timeAxis) {\n      var data = outputs[outp.id].data[countryCode];\n\n      if (data.length) {\n        data = data.map(function (value, index) {\n          // side-effect: also sum up the total-data\n          if (withNegative) {\n            if (!totalData[index]) {\n              totalData[index] = {\n                x: timeAxis[index],\n                y: 0\n              };\n            }\n\n            totalData[index].y += value;\n          } // modify the data format from [xValue,yValue] to {x:xValue, y:yValue}\n\n\n          return {\n            x: timeAxis[index],\n            y: chartDef.modifier ? chartDef.modifier(value) : value\n          };\n        });\n\n        if (data.length === timeAxis.length) {\n          series.push({\n            name: outp.title ? outp.title : outputs[outp.id].title,\n            id: outp.id,\n            //necessary for chart update\n            color: outp.color ? outp.color : undefined,\n            data: data\n          });\n        }\n      }\n    }\n  }); // if API data is not available yet, this case is caught outisde of this function already\n  // but this check is still kept for security reasons\n\n  if (!timeAxis) {\n    return;\n  }\n\n  if (withNegative) {\n    series = formatSeriesWithNullstellen(timeAxis, series);\n    var totalSeries = {\n      type: 'line',\n      name: chartDef.totalTitle ? chartDef.totalTitle : 'total',\n      id: 'total',\n      color: '#f44141',\n      data: totalData\n    };\n    series.push(totalSeries);\n  }\n\n  return {\n    series: series,\n    title: chartDef.title,\n    unit: chartDef.unit,\n    timeAxis: timeAxis.slice() // ditch observer\n\n  };\n}\n\nfunction formatSeriesWithNullstellen(timeAxis, series) {\n  // timeAxis: [..,2012,2013,2014,..]\n  // series: [{name: \"\", id: \"\", color: \"\", data: [{x:1,y:2}, {x:2,y:3}, ..]}, ..]\n  // all series-data should be sanitized/filtered already!\n  // timeAxis.length must match all data.length\n  var _findNullstellen = findNullstellen(timeAxis, series),\n      _findNullstellen2 = _slicedToArray(_findNullstellen, 2),\n      nullstellen = _findNullstellen2[0],\n      nullStellenBySeriesId = _findNullstellen2[1]; // nullstellen does not contain any values which are already part of the timeAxis\n  // calculate intermediate values for all series (necessary, otherwise gaps appear in areas where no data is defined)\n\n\n  nullstellen.forEach(function (nullst) {\n    series.forEach(function (ser) {\n      var seriesContainsEntry = ser.data.some(function (point) {\n        return point.x === nullst.x;\n      });\n\n      if (!seriesContainsEntry) {\n        var y;\n\n        if (nullStellenBySeriesId[ser.id] && nullStellenBySeriesId[ser.id].indexOf(nullst.x) >= 0) {\n          y = 0;\n        } else {\n          //linear interpolation\n          var pointBefore = ser.data.find(function (point) {\n            return point.x === nullst.xBefore;\n          });\n          var pointAfter = ser.data.find(function (point) {\n            return point.x === nullst.xAfter;\n          });\n          y = linearInterpolatePoint(nullst.x, nullst.xBefore, nullst.xAfter, pointBefore.y, pointAfter.y);\n        }\n\n        if (typeof y !== \"undefined\") {\n          ser.data.push({\n            x: nullst.x,\n            y: y,\n            // states: {hover: {enabled: false}},\n            // marker: {enabled: false},\n            marker: {\n              states: {\n                hover: {\n                  enabled: false\n                }\n              }\n            },\n            noTooltip: true\n          });\n        }\n      }\n    });\n  }); // sort all data arrays of all series (Highcharts need data to be sorted by x)\n\n  series.forEach(function (ser) {\n    ser.data.sort(function compare(a, b) {\n      if (a.x < b.x) {\n        return -1;\n      }\n\n      if (a.x > b.x) {\n        return 1;\n      } // a must be equal to b\n\n\n      return 0;\n    });\n  }); // split seriesData according to positive or negative stack\n  // important! The series.data need to be sorted already!\n\n  var _splitSeriesData = splitSeriesData(series),\n      _splitSeriesData2 = _slicedToArray(_splitSeriesData, 2),\n      positiveSeries = _splitSeriesData2[0],\n      negativeSeries = _splitSeriesData2[1];\n\n  series = positiveSeries.concat(negativeSeries);\n  return series;\n}\n\nexport function findNullstellen(timeAxis, seriesData) {\n  var xTolerance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.001;\n  // timeAxis: [..,2012,2013,2014,..]\n  // seriesData: [{id: \"\", data: [{y:2}, {y:3}, ..]}, ..]\n  // returns all Nullstellen of all series in seriesData merged into one object (intermediateTimes)\n  // ignores nullstellen that already land on a timeAxis-Stelle\n  var intermediateTimes = []; // [{x: 2012.4, xBefore: 2012, xAfter: 2013}]\n\n  var nullStellenBySeriesId = {}; // {\"someId\": [2012.4, 2015.6], ..}\n\n  seriesData.forEach(function (ser) {\n    var activePart = \"positive\";\n    var valueBefore;\n\n    for (var i = 0, len = timeAxis.length; i < len; i++) {\n      var x = timeAxis[i];\n      var value = ser.data[i].y;\n      var crossingFound = void 0; // switch activePart on sign change\n      // zero values are ignored, because they are already part of the series\n      // and duplicate datapoints would lead to bugs in rendering\n\n      if (value < 0) {\n        if (activePart === \"positive\" && i > 0 && i < len) {\n          crossingFound = true;\n        }\n\n        activePart = \"negative\";\n      }\n\n      if (value > 0) {\n        if (activePart === \"negative\" && i > 0 && i < len) {\n          crossingFound = true;\n        }\n\n        activePart = \"positive\";\n      }\n\n      if (crossingFound) {\n        var xBefore = timeAxis[i - 1];\n        var m = (value - valueBefore) / (x - xBefore); // x and xBefore are sometimes more than one unit apart!!\n\n        var x0 = -1 * valueBefore / m + xBefore; //y1/m + x1\n        // don't add Nullstellen that already exist in the timeAxis, because duplicate datapoints lead to rendering errors\n        // also don't add datapoints if the nullStelle is already within tolerance to an already existing datapoint\n\n        if (timeAxis.indexOf(x0) >= 0 || x0 - xBefore < xTolerance || x - x0 < xTolerance) {\n          continue;\n        } // setting toFixed() to 6 is important, if setting toFixed(2) sometimes it hits a round year\n        // which results in double entries in data, because parseFloat is ignoring zero decimals.\n        // parseFloat(2009.00) =>> 2009\n        // also if there are two equal nullstellen which might happen with toFixed(2)\n        // it also results in the error, that the highcharts updates are jumpy\n        // I haven't been able to fully track down the error, but using .toFixed(6)\n        // mitigates it and makes it much less likely to occur\n\n\n        intermediateTimes.push({\n          // x: nullStelle,\n          x: x0,\n          xBefore: xBefore,\n          xAfter: x\n        });\n\n        if (nullStellenBySeriesId[ser.id]) {\n          nullStellenBySeriesId[ser.id].push(x0);\n        } else {\n          nullStellenBySeriesId[ser.id] = [x0];\n        }\n      }\n\n      valueBefore = value;\n    }\n  });\n  return [intermediateTimes, nullStellenBySeriesId];\n}\n\nfunction linearInterpolatePoint(x, xBefore, xAfter, yBefore, yAfter) {\n  var y;\n\n  if (typeof xBefore !== 'undefined' && typeof xAfter !== 'undefined' && typeof yBefore !== 'undefined' && typeof yAfter !== 'undefined') {\n    var m = (yAfter - yBefore) / (xAfter - xBefore);\n    y = m * (x - xBefore) + yBefore;\n  } // y can be undefined\n\n\n  return y;\n}\n\nfunction splitSeriesData(seriesData) {\n  // all series.data needs to be sorted already\n  // [{x:2015, y: 10},{x: 2015.5, y: 0},{x: 2016, y: 0},{x: 2017},{},{},{},{}]\n  //\n  // only y:0 are relevant\n  // when 0 is hit it gets written in the currentactivePart\n  // when a sign change happens to negative, the negative value gets written in the negativePart,\n  // but also the negativePart needs the 0 in it entered for the xBefore\n  //\n  // It always hits the 0, it never jumps directly to negative values!\n  // If it hits the 0 and the next value has a different sign, then the 0 gets written in both parts.\n  var positiveSeries = [];\n  var negativeSeries = [];\n  seriesData.forEach(function (series) {\n    var data = series.data;\n    var positiveData = [];\n    var negativeData = [];\n    var activePart = positiveData;\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      var point = data[i];\n      var y = data[i].y;\n\n      if (y > 0) {\n        positiveData.push(point);\n        activePart = positiveData;\n      }\n\n      if (y < 0) {\n        negativeData.push(point);\n        activePart = negativeData;\n      }\n\n      if (y === 0) {\n        //ignore when first or last entry\n        if (i > 0 && i < len - 1) {\n          var yBefore = data[i - 1].y;\n          var yAfter = data[i + 1].y;\n\n          if (Math.sign(yBefore) !== Math.sign(yAfter)) {\n            // push to both parts, when 0 is followed by a sign change\n            // but disable the tooltip for one\n            positiveData.push(point);\n            negativeData.push(_objectSpread({}, point, {\n              //spread operator\n              noTooltip: true\n            }));\n          } else {\n            // if no sign change, just push to current active part\n            activePart.push(point);\n          }\n        } else {\n          // if 0 is first or last value it gets pushed to the current active part.\n          // activePart is positiveData for i==0\n          activePart.push(point);\n        }\n      }\n    }\n\n    positiveSeries.push({\n      name: series.name,\n      type: 'area',\n      id: series.id ? series.id : series.name,\n      data: positiveData,\n      stack: 'positive',\n      color: series.color ? series.color : undefined\n    });\n    negativeSeries.push({\n      name: series.name,\n      type: 'area',\n      linkedTo: series.id,\n      id: series.id ? series.id + 'neg' : series.name + 'neg',\n      //id also necessary for negative series (for animated data update) I guess\n      data: negativeData,\n      stack: 'negative',\n      color: series.color ? series.color : undefined\n    });\n  });\n  return [positiveSeries, negativeSeries];\n}",{"version":3,"sources":["/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/src/chartSeriesBuilders.js"],"names":["buildChartData","countryCode","chartDef","outputs","withNegative","timeAxis","series","totalData","forEach","outp","custom","id","data","length","map","value","index","x","y","modifier","push","name","title","color","undefined","formatSeriesWithNullstellen","totalSeries","type","totalTitle","unit","slice","findNullstellen","nullstellen","nullStellenBySeriesId","nullst","ser","seriesContainsEntry","some","point","indexOf","pointBefore","find","xBefore","pointAfter","xAfter","linearInterpolatePoint","marker","states","hover","enabled","noTooltip","sort","compare","a","b","splitSeriesData","positiveSeries","negativeSeries","concat","seriesData","xTolerance","intermediateTimes","activePart","valueBefore","i","len","crossingFound","m","x0","yBefore","yAfter","positiveData","negativeData","Math","sign","stack","linkedTo"],"mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AAEA,OAAO,SAASA,cAAT,CAAwBC,WAAxB,EAAqCC,QAArC,EAA+CC,OAA/C,EAAwDC,YAAxD,EAAsE;AAC3E,MAAIC,QAAJ;AACA,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIC,SAAS,GAAG,EAAhB,CAH2E,CAK3E;;AACAL,EAAAA,QAAQ,CAACC,OAAT,CAAiBK,OAAjB,CAAyB,UAACC,IAAD,EAAU;AAEjC;AACA,QAAGA,IAAI,CAACC,MAAR,EAAgB;AACd;AACD,KALgC,CAOjC;AACA;AACA;AACA;;;AACA,QAAG,CAACP,OAAO,CAACM,IAAI,CAACE,EAAN,CAAR,IAAqB,CAACR,OAAO,CAACM,IAAI,CAACE,EAAN,CAAP,CAAiBC,IAA1C,EAAgD;AAC9C;AACD;;AACD,QAAG,CAACP,QAAJ,EAAc;AACZ;AACA;AACAA,MAAAA,QAAQ,GAAGF,OAAO,CAACM,IAAI,CAACE,EAAN,CAAP,CAAiBN,QAA5B;AACD;;AAED,QAAGA,QAAH,EAAa;AACX,UAAIO,IAAI,GAAGT,OAAO,CAACM,IAAI,CAACE,EAAN,CAAP,CAAiBC,IAAjB,CAAsBX,WAAtB,CAAX;;AAEA,UAAGW,IAAI,CAACC,MAAR,EAAgB;AACdD,QAAAA,IAAI,GAAGA,IAAI,CAACE,GAAL,CAAS,UAACC,KAAD,EAAQC,KAAR,EAAkB;AAEhC;AACA,cAAGZ,YAAH,EAAiB;AACf,gBAAG,CAACG,SAAS,CAACS,KAAD,CAAb,EAAsB;AACpBT,cAAAA,SAAS,CAACS,KAAD,CAAT,GAAmB;AACjBC,gBAAAA,CAAC,EAAEZ,QAAQ,CAACW,KAAD,CADM;AAEjBE,gBAAAA,CAAC,EAAE;AAFc,eAAnB;AAID;;AACDX,YAAAA,SAAS,CAACS,KAAD,CAAT,CAAiBE,CAAjB,IAAsBH,KAAtB;AACD,WAX+B,CAahC;;;AACA,iBAAO;AACLE,YAAAA,CAAC,EAAEZ,QAAQ,CAACW,KAAD,CADN;AAELE,YAAAA,CAAC,EAAEhB,QAAQ,CAACiB,QAAT,GAAoBjB,QAAQ,CAACiB,QAAT,CAAkBJ,KAAlB,CAApB,GAA+CA;AAF7C,WAAP;AAID,SAlBM,CAAP;;AAoBA,YAAGH,IAAI,CAACC,MAAL,KAAgBR,QAAQ,CAACQ,MAA5B,EAAoC;AAClCP,UAAAA,MAAM,CAACc,IAAP,CAAY;AACVC,YAAAA,IAAI,EAAEZ,IAAI,CAACa,KAAL,GAAab,IAAI,CAACa,KAAlB,GAA0BnB,OAAO,CAACM,IAAI,CAACE,EAAN,CAAP,CAAiBW,KADvC;AAEVX,YAAAA,EAAE,EAAEF,IAAI,CAACE,EAFC;AAEG;AACbY,YAAAA,KAAK,EAAEd,IAAI,CAACc,KAAL,GAAad,IAAI,CAACc,KAAlB,GAA0BC,SAHvB;AAIVZ,YAAAA,IAAI,EAAEA;AAJI,WAAZ;AAMD;AACF;AACF;AACF,GAtDD,EAN2E,CA8D3E;AACA;;AACA,MAAG,CAACP,QAAJ,EAAc;AACZ;AACD;;AAED,MAAGD,YAAH,EAAiB;AACfE,IAAAA,MAAM,GAAGmB,2BAA2B,CAACpB,QAAD,EAAWC,MAAX,CAApC;AAEA,QAAIoB,WAAW,GAAG;AAChBC,MAAAA,IAAI,EAAE,MADU;AAEhBN,MAAAA,IAAI,EAAEnB,QAAQ,CAAC0B,UAAT,GAAsB1B,QAAQ,CAAC0B,UAA/B,GAA4C,OAFlC;AAGhBjB,MAAAA,EAAE,EAAE,OAHY;AAIhBY,MAAAA,KAAK,EAAE,SAJS;AAKhBX,MAAAA,IAAI,EAAEL;AALU,KAAlB;AAOAD,IAAAA,MAAM,CAACc,IAAP,CAAYM,WAAZ;AACD;;AAED,SAAO;AACLpB,IAAAA,MAAM,EAAEA,MADH;AAELgB,IAAAA,KAAK,EAAEpB,QAAQ,CAACoB,KAFX;AAGLO,IAAAA,IAAI,EAAE3B,QAAQ,CAAC2B,IAHV;AAILxB,IAAAA,QAAQ,EAAEA,QAAQ,CAACyB,KAAT,EAJL,CAIsB;;AAJtB,GAAP;AAMD;;AAED,SAASL,2BAAT,CAAqCpB,QAArC,EAA+CC,MAA/C,EAAuD;AACrD;AACA;AACA;AACA;AAJqD,yBAMVyB,eAAe,CAAC1B,QAAD,EAAWC,MAAX,CANL;AAAA;AAAA,MAMhD0B,WANgD;AAAA,MAMnCC,qBANmC,yBAOrD;AAEA;;;AACAD,EAAAA,WAAW,CAACxB,OAAZ,CAAoB,UAAC0B,MAAD,EAAY;AAE9B5B,IAAAA,MAAM,CAACE,OAAP,CAAe,UAAC2B,GAAD,EAAS;AACtB,UAAIC,mBAAmB,GAAGD,GAAG,CAACvB,IAAJ,CAASyB,IAAT,CAAc,UAACC,KAAD,EAAW;AACjD,eAAOA,KAAK,CAACrB,CAAN,KAAYiB,MAAM,CAACjB,CAA1B;AACD,OAFyB,CAA1B;;AAGA,UAAG,CAACmB,mBAAJ,EAAyB;AACvB,YAAIlB,CAAJ;;AAEA,YAAGe,qBAAqB,CAACE,GAAG,CAACxB,EAAL,CAArB,IAAiCsB,qBAAqB,CAACE,GAAG,CAACxB,EAAL,CAArB,CAA8B4B,OAA9B,CAAsCL,MAAM,CAACjB,CAA7C,KAAmD,CAAvF,EAA0F;AACxFC,UAAAA,CAAC,GAAG,CAAJ;AACD,SAFD,MAEO;AACL;AACA,cAAIsB,WAAW,GAAGL,GAAG,CAACvB,IAAJ,CAAS6B,IAAT,CAAc,UAACH,KAAD;AAAA,mBAAWA,KAAK,CAACrB,CAAN,KAAYiB,MAAM,CAACQ,OAA9B;AAAA,WAAd,CAAlB;AACA,cAAIC,UAAU,GAAGR,GAAG,CAACvB,IAAJ,CAAS6B,IAAT,CAAc,UAACH,KAAD;AAAA,mBAAWA,KAAK,CAACrB,CAAN,KAAYiB,MAAM,CAACU,MAA9B;AAAA,WAAd,CAAjB;AACA1B,UAAAA,CAAC,GAAG2B,sBAAsB,CAACX,MAAM,CAACjB,CAAR,EAAWiB,MAAM,CAACQ,OAAlB,EAA2BR,MAAM,CAACU,MAAlC,EAA0CJ,WAAW,CAACtB,CAAtD,EAAyDyB,UAAU,CAACzB,CAApE,CAA1B;AACD;;AAED,YAAG,OAAOA,CAAP,KAAa,WAAhB,EAA6B;AAC3BiB,UAAAA,GAAG,CAACvB,IAAJ,CAASQ,IAAT,CAAc;AACZH,YAAAA,CAAC,EAAEiB,MAAM,CAACjB,CADE;AAEZC,YAAAA,CAAC,EAAEA,CAFS;AAGZ;AACA;AACA4B,YAAAA,MAAM,EAAE;AACNC,cAAAA,MAAM,EAAE;AACNC,gBAAAA,KAAK,EAAE;AACLC,kBAAAA,OAAO,EAAE;AADJ;AADD;AADF,aALI;AAYZC,YAAAA,SAAS,EAAE;AAZC,WAAd;AAcD;AACF;AACF,KAjCD;AAkCD,GApCD,EAVqD,CAgDrD;;AACA5C,EAAAA,MAAM,CAACE,OAAP,CAAe,UAAC2B,GAAD,EAAQ;AACrBA,IAAAA,GAAG,CAACvB,IAAJ,CAASuC,IAAT,CAAc,SAASC,OAAT,CAAiBC,CAAjB,EAAoBC,CAApB,EAAuB;AACnC,UAAID,CAAC,CAACpC,CAAF,GAAMqC,CAAC,CAACrC,CAAZ,EAAe;AACb,eAAO,CAAC,CAAR;AACD;;AACD,UAAIoC,CAAC,CAACpC,CAAF,GAAMqC,CAAC,CAACrC,CAAZ,EAAe;AACb,eAAO,CAAP;AACD,OANkC,CAOnC;;;AACA,aAAO,CAAP;AACD,KATD;AAUD,GAXD,EAjDqD,CA8DrD;AACA;;AA/DqD,yBAgEdsC,eAAe,CAACjD,MAAD,CAhED;AAAA;AAAA,MAgEhDkD,cAhEgD;AAAA,MAgEhCC,cAhEgC;;AAkErDnD,EAAAA,MAAM,GAAGkD,cAAc,CAACE,MAAf,CAAsBD,cAAtB,CAAT;AAEA,SAAOnD,MAAP;AACD;;AAED,OAAO,SAASyB,eAAT,CAAyB1B,QAAzB,EAAmCsD,UAAnC,EAAiE;AAAA,MAAlBC,UAAkB,uEAAP,KAAO;AACtE;AACA;AACA;AACA;AAEA,MAAIC,iBAAiB,GAAG,EAAxB,CANsE,CAM1C;;AAE5B,MAAI5B,qBAAqB,GAAG,EAA5B,CARsE,CAQtC;;AAEhC0B,EAAAA,UAAU,CAACnD,OAAX,CAAmB,UAAC2B,GAAD,EAAS;AAE1B,QAAI2B,UAAU,GAAG,UAAjB;AACA,QAAIC,WAAJ;;AAEA,SAAI,IAAIC,CAAC,GAAC,CAAN,EAASC,GAAG,GAAC5D,QAAQ,CAACQ,MAA1B,EAAkCmD,CAAC,GAACC,GAApC,EAAyCD,CAAC,EAA1C,EAA8C;AAC5C,UAAI/C,CAAC,GAAGZ,QAAQ,CAAC2D,CAAD,CAAhB;AACA,UAAIjD,KAAK,GAAGoB,GAAG,CAACvB,IAAJ,CAASoD,CAAT,EAAY9C,CAAxB;AACA,UAAIgD,aAAa,SAAjB,CAH4C,CAK5C;AACA;AACA;;AACA,UAAGnD,KAAK,GAAG,CAAX,EAAc;AACZ,YAAG+C,UAAU,KAAK,UAAf,IAA6BE,CAAC,GAAG,CAAjC,IAAsCA,CAAC,GAAGC,GAA7C,EAAkD;AAChDC,UAAAA,aAAa,GAAG,IAAhB;AACD;;AACDJ,QAAAA,UAAU,GAAG,UAAb;AACD;;AACD,UAAG/C,KAAK,GAAG,CAAX,EAAc;AACZ,YAAG+C,UAAU,KAAK,UAAf,IAA6BE,CAAC,GAAG,CAAjC,IAAsCA,CAAC,GAAGC,GAA7C,EAAkD;AAChDC,UAAAA,aAAa,GAAG,IAAhB;AACD;;AACDJ,QAAAA,UAAU,GAAG,UAAb;AACD;;AAED,UAAGI,aAAH,EAAkB;AAEhB,YAAIxB,OAAO,GAAGrC,QAAQ,CAAC2D,CAAC,GAAC,CAAH,CAAtB;AAEA,YAAIG,CAAC,GAAG,CAACpD,KAAK,GAAGgD,WAAT,KAAyB9C,CAAC,GAACyB,OAA3B,CAAR,CAJgB,CAI6B;;AAC7C,YAAI0B,EAAE,GAAG,CAAC,CAAD,GAAGL,WAAH,GAAeI,CAAf,GAAmBzB,OAA5B,CALgB,CAKqB;AAErC;AACA;;AACA,YAAGrC,QAAQ,CAACkC,OAAT,CAAiB6B,EAAjB,KAAwB,CAAxB,IAA6BA,EAAE,GAAG1B,OAAL,GAAekB,UAA5C,IAA0D3C,CAAC,GAAGmD,EAAJ,GAASR,UAAtE,EAAkF;AAChF;AACD,SAXe,CAahB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAC,QAAAA,iBAAiB,CAACzC,IAAlB,CAAuB;AACrB;AACAH,UAAAA,CAAC,EAAEmD,EAFkB;AAGrB1B,UAAAA,OAAO,EAAEA,OAHY;AAIrBE,UAAAA,MAAM,EAAE3B;AAJa,SAAvB;;AAMA,YAAGgB,qBAAqB,CAACE,GAAG,CAACxB,EAAL,CAAxB,EAAkC;AAChCsB,UAAAA,qBAAqB,CAACE,GAAG,CAACxB,EAAL,CAArB,CAA8BS,IAA9B,CAAmCgD,EAAnC;AACD,SAFD,MAEO;AACLnC,UAAAA,qBAAqB,CAACE,GAAG,CAACxB,EAAL,CAArB,GAAgC,CAACyD,EAAD,CAAhC;AACD;AAEF;;AACDL,MAAAA,WAAW,GAAGhD,KAAd;AAED;AACF,GA/DD;AAiEA,SAAO,CAAC8C,iBAAD,EAAoB5B,qBAApB,CAAP;AACD;;AAGD,SAASY,sBAAT,CAAgC5B,CAAhC,EAAmCyB,OAAnC,EAA4CE,MAA5C,EAAoDyB,OAApD,EAA6DC,MAA7D,EAAqE;AACnE,MAAIpD,CAAJ;;AAEA,MAAG,OAAOwB,OAAP,KAAmB,WAAnB,IAAkC,OAAOE,MAAP,KAAkB,WAApD,IAAmE,OAAOyB,OAAP,KAAmB,WAAtF,IAAqG,OAAOC,MAAP,KAAkB,WAA1H,EAAuI;AACrI,QAAIH,CAAC,GAAG,CAACG,MAAM,GAAGD,OAAV,KAAoBzB,MAAM,GAACF,OAA3B,CAAR;AACAxB,IAAAA,CAAC,GAAGiD,CAAC,IAAElD,CAAC,GAACyB,OAAJ,CAAD,GAAgB2B,OAApB;AACD,GANkE,CAOnE;;;AACA,SAAOnD,CAAP;AACD;;AAED,SAASqC,eAAT,CAAyBI,UAAzB,EAAqC;AACnC;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA,MAAIH,cAAc,GAAG,EAArB;AACA,MAAIC,cAAc,GAAG,EAArB;AAEAE,EAAAA,UAAU,CAACnD,OAAX,CAAmB,UAACF,MAAD,EAAY;AAE7B,QAAIM,IAAI,GAAGN,MAAM,CAACM,IAAlB;AACA,QAAI2D,YAAY,GAAG,EAAnB;AACA,QAAIC,YAAY,GAAG,EAAnB;AAEA,QAAIV,UAAU,GAAGS,YAAjB;;AAEA,SAAI,IAAIP,CAAC,GAAC,CAAN,EAASC,GAAG,GAACrD,IAAI,CAACC,MAAtB,EAA8BmD,CAAC,GAACC,GAAhC,EAAqCD,CAAC,EAAtC,EAA0C;AACxC,UAAI1B,KAAK,GAAG1B,IAAI,CAACoD,CAAD,CAAhB;AACA,UAAI9C,CAAC,GAAGN,IAAI,CAACoD,CAAD,CAAJ,CAAQ9C,CAAhB;;AAEA,UAAGA,CAAC,GAAG,CAAP,EAAU;AACRqD,QAAAA,YAAY,CAACnD,IAAb,CAAkBkB,KAAlB;AACAwB,QAAAA,UAAU,GAAGS,YAAb;AACD;;AACD,UAAGrD,CAAC,GAAG,CAAP,EAAU;AACRsD,QAAAA,YAAY,CAACpD,IAAb,CAAkBkB,KAAlB;AACAwB,QAAAA,UAAU,GAAGU,YAAb;AACD;;AACD,UAAGtD,CAAC,KAAK,CAAT,EAAY;AACV;AACA,YAAG8C,CAAC,GAAG,CAAJ,IAASA,CAAC,GAAGC,GAAG,GAAC,CAApB,EAAuB;AACrB,cAAII,OAAO,GAAGzD,IAAI,CAACoD,CAAC,GAAC,CAAH,CAAJ,CAAU9C,CAAxB;AACA,cAAIoD,MAAM,GAAE1D,IAAI,CAACoD,CAAC,GAAC,CAAH,CAAJ,CAAU9C,CAAtB;;AACA,cAAGuD,IAAI,CAACC,IAAL,CAAUL,OAAV,MAAuBI,IAAI,CAACC,IAAL,CAAUJ,MAAV,CAA1B,EAA6C;AAC3C;AACA;AACAC,YAAAA,YAAY,CAACnD,IAAb,CAAkBkB,KAAlB;AACAkC,YAAAA,YAAY,CAACpD,IAAb,mBACKkB,KADL;AACY;AACVY,cAAAA,SAAS,EAAE;AAFb;AAID,WARD,MAQO;AACL;AACAY,YAAAA,UAAU,CAAC1C,IAAX,CAAgBkB,KAAhB;AACD;AACF,SAfD,MAeO;AACL;AACA;AACAwB,UAAAA,UAAU,CAAC1C,IAAX,CAAgBkB,KAAhB;AACD;AACF;AACF;;AAEDkB,IAAAA,cAAc,CAACpC,IAAf,CAAoB;AAClBC,MAAAA,IAAI,EAAEf,MAAM,CAACe,IADK;AAElBM,MAAAA,IAAI,EAAE,MAFY;AAGlBhB,MAAAA,EAAE,EAAEL,MAAM,CAACK,EAAP,GAAYL,MAAM,CAACK,EAAnB,GAAwBL,MAAM,CAACe,IAHjB;AAIlBT,MAAAA,IAAI,EAAE2D,YAJY;AAKlBI,MAAAA,KAAK,EAAE,UALW;AAMlBpD,MAAAA,KAAK,EAAEjB,MAAM,CAACiB,KAAP,GAAejB,MAAM,CAACiB,KAAtB,GAA8BC;AANnB,KAApB;AASAiC,IAAAA,cAAc,CAACrC,IAAf,CAAoB;AAClBC,MAAAA,IAAI,EAAEf,MAAM,CAACe,IADK;AAElBM,MAAAA,IAAI,EAAE,MAFY;AAGlBiD,MAAAA,QAAQ,EAAEtE,MAAM,CAACK,EAHC;AAIlBA,MAAAA,EAAE,EAAEL,MAAM,CAACK,EAAP,GAAYL,MAAM,CAACK,EAAP,GAAW,KAAvB,GAA+BL,MAAM,CAACe,IAAP,GAAa,KAJ9B;AAIqC;AACvDT,MAAAA,IAAI,EAAE4D,YALY;AAMlBG,MAAAA,KAAK,EAAE,UANW;AAOlBpD,MAAAA,KAAK,EAAEjB,MAAM,CAACiB,KAAP,GAAejB,MAAM,CAACiB,KAAtB,GAA8BC;AAPnB,KAApB;AAUD,GAhED;AAkEA,SAAO,CAACgC,cAAD,EAAiBC,cAAjB,CAAP;AACD","sourcesContent":["// TODO:\n// restructure this module for more readability\n// findNullstellen should only accept a single series and only require the series with x and y values as a single parameter\n\nexport function buildChartData(countryCode, chartDef, outputs, withNegative) {\n  var timeAxis;\n  var series = [];\n  var totalData = [];\n\n  // chartDef.outputs only contains the keys (strings) used in outputs\n  chartDef.outputs.forEach((outp) => {\n\n    // skip custom outputs\n    if(outp.custom) {\n      return;\n    }\n\n    // outputs[outp] might exist (created from frontend config file),\n    // but outputs[outp].data or outputs[outp].timeAxis might not exist (if this output is unknown to the API)\n    // if an output is unknown to API and it wasn't listed in the Outputs config constant, then outputs[outp] is undefined\n    // outputs that are not listed in the Outputs config constant only get initialized into outputs on a succesful API fetch\n    if(!outputs[outp.id] || !outputs[outp.id].data) {\n      return;\n    }\n    if(!timeAxis) {\n      // outp.timeAxis can still be undefined (if output is unknown to API),\n      // but then it is looked for one on the next iteration\n      timeAxis = outputs[outp.id].timeAxis;\n    }\n\n    if(timeAxis) {\n      let data = outputs[outp.id].data[countryCode];\n\n      if(data.length) {\n        data = data.map((value, index) => {\n\n          // side-effect: also sum up the total-data\n          if(withNegative) {\n            if(!totalData[index]) {\n              totalData[index] = {\n                x: timeAxis[index],\n                y: 0\n              };\n            }\n            totalData[index].y += value;\n          }\n\n          // modify the data format from [xValue,yValue] to {x:xValue, y:yValue}\n          return {\n            x: timeAxis[index],\n            y: chartDef.modifier ? chartDef.modifier(value) : value\n          };\n        });\n\n        if(data.length === timeAxis.length) {\n          series.push({\n            name: outp.title ? outp.title : outputs[outp.id].title,\n            id: outp.id, //necessary for chart update\n            color: outp.color ? outp.color : undefined,\n            data: data\n          });\n        }\n      }\n    }\n  });\n\n  // if API data is not available yet, this case is caught outisde of this function already\n  // but this check is still kept for security reasons\n  if(!timeAxis) {\n    return;\n  }\n\n  if(withNegative) {\n    series = formatSeriesWithNullstellen(timeAxis, series);\n\n    let totalSeries = {\n      type: 'line',\n      name: chartDef.totalTitle ? chartDef.totalTitle : 'total',\n      id: 'total',\n      color: '#f44141',\n      data: totalData\n    };\n    series.push(totalSeries);\n  }\n\n  return {\n    series: series,\n    title: chartDef.title,\n    unit: chartDef.unit,\n    timeAxis: timeAxis.slice() // ditch observer\n  }\n}\n\nfunction formatSeriesWithNullstellen(timeAxis, series) {\n  // timeAxis: [..,2012,2013,2014,..]\n  // series: [{name: \"\", id: \"\", color: \"\", data: [{x:1,y:2}, {x:2,y:3}, ..]}, ..]\n  // all series-data should be sanitized/filtered already!\n  // timeAxis.length must match all data.length\n\n  let [nullstellen, nullStellenBySeriesId] = findNullstellen(timeAxis, series);\n  // nullstellen does not contain any values which are already part of the timeAxis\n\n  // calculate intermediate values for all series (necessary, otherwise gaps appear in areas where no data is defined)\n  nullstellen.forEach((nullst) => {\n\n    series.forEach((ser) => {\n      let seriesContainsEntry = ser.data.some((point) => {\n        return point.x === nullst.x;\n      });\n      if(!seriesContainsEntry) {\n        let y;\n\n        if(nullStellenBySeriesId[ser.id] && nullStellenBySeriesId[ser.id].indexOf(nullst.x) >= 0) {\n          y = 0;\n        } else {\n          //linear interpolation\n          let pointBefore = ser.data.find((point) => point.x === nullst.xBefore);\n          let pointAfter = ser.data.find((point) => point.x === nullst.xAfter);\n          y = linearInterpolatePoint(nullst.x, nullst.xBefore, nullst.xAfter, pointBefore.y, pointAfter.y);\n        }\n\n        if(typeof y !== \"undefined\") {\n          ser.data.push({\n            x: nullst.x,\n            y: y,\n            // states: {hover: {enabled: false}},\n            // marker: {enabled: false},\n            marker: {\n              states: {\n                hover: {\n                  enabled: false\n                }\n              }\n            },\n            noTooltip: true\n          });\n        }\n      }\n    });\n  });\n\n  // sort all data arrays of all series (Highcharts need data to be sorted by x)\n  series.forEach((ser)=> {\n    ser.data.sort(function compare(a, b) {\n      if (a.x < b.x) {\n        return -1;\n      }\n      if (a.x > b.x) {\n        return 1;\n      }\n      // a must be equal to b\n      return 0;\n    })\n  });\n\n  // split seriesData according to positive or negative stack\n  // important! The series.data need to be sorted already!\n  let [positiveSeries, negativeSeries] = splitSeriesData(series);\n\n  series = positiveSeries.concat(negativeSeries);\n\n  return series;\n}\n\nexport function findNullstellen(timeAxis, seriesData, xTolerance=0.001) {\n  // timeAxis: [..,2012,2013,2014,..]\n  // seriesData: [{id: \"\", data: [{y:2}, {y:3}, ..]}, ..]\n  // returns all Nullstellen of all series in seriesData merged into one object (intermediateTimes)\n  // ignores nullstellen that already land on a timeAxis-Stelle\n\n  let intermediateTimes = []; // [{x: 2012.4, xBefore: 2012, xAfter: 2013}]\n\n  let nullStellenBySeriesId = {}; // {\"someId\": [2012.4, 2015.6], ..}\n\n  seriesData.forEach((ser) => {\n\n    let activePart = \"positive\";\n    let valueBefore;\n\n    for(let i=0, len=timeAxis.length; i<len; i++) {\n      let x = timeAxis[i];\n      let value = ser.data[i].y;\n      let crossingFound;\n\n      // switch activePart on sign change\n      // zero values are ignored, because they are already part of the series\n      // and duplicate datapoints would lead to bugs in rendering\n      if(value < 0) {\n        if(activePart === \"positive\" && i > 0 && i < len) {\n          crossingFound = true;\n        }\n        activePart = \"negative\";\n      }\n      if(value > 0) {\n        if(activePart === \"negative\" && i > 0 && i < len) {\n          crossingFound = true;\n        }\n        activePart = \"positive\";\n      }\n\n      if(crossingFound) {\n\n        let xBefore = timeAxis[i-1];\n\n        let m = (value - valueBefore) / (x-xBefore); // x and xBefore are sometimes more than one unit apart!!\n        let x0 = -1*valueBefore/m + xBefore; //y1/m + x1\n\n        // don't add Nullstellen that already exist in the timeAxis, because duplicate datapoints lead to rendering errors\n        // also don't add datapoints if the nullStelle is already within tolerance to an already existing datapoint\n        if(timeAxis.indexOf(x0) >= 0 || x0 - xBefore < xTolerance || x - x0 < xTolerance) {\n          continue;\n        }\n\n        // setting toFixed() to 6 is important, if setting toFixed(2) sometimes it hits a round year\n        // which results in double entries in data, because parseFloat is ignoring zero decimals.\n        // parseFloat(2009.00) =>> 2009\n        // also if there are two equal nullstellen which might happen with toFixed(2)\n        // it also results in the error, that the highcharts updates are jumpy\n        // I haven't been able to fully track down the error, but using .toFixed(6)\n        // mitigates it and makes it much less likely to occur\n\n        intermediateTimes.push({\n          // x: nullStelle,\n          x: x0,\n          xBefore: xBefore,\n          xAfter: x\n        });\n        if(nullStellenBySeriesId[ser.id]) {\n          nullStellenBySeriesId[ser.id].push(x0);\n        } else {\n          nullStellenBySeriesId[ser.id] = [x0];\n        }\n\n      }\n      valueBefore = value;\n\n    }\n  });\n\n  return [intermediateTimes, nullStellenBySeriesId];\n}\n\n\nfunction linearInterpolatePoint(x, xBefore, xAfter, yBefore, yAfter) {\n  let y;\n\n  if(typeof xBefore !== 'undefined' && typeof xAfter !== 'undefined' && typeof yBefore !== 'undefined' && typeof yAfter !== 'undefined') {\n    let m = (yAfter - yBefore)/(xAfter-xBefore);\n    y = m*(x-xBefore) + yBefore;\n  }\n  // y can be undefined\n  return y;\n}\n\nfunction splitSeriesData(seriesData) {\n  // all series.data needs to be sorted already\n\n\n  // [{x:2015, y: 10},{x: 2015.5, y: 0},{x: 2016, y: 0},{x: 2017},{},{},{},{}]\n  //\n  // only y:0 are relevant\n  // when 0 is hit it gets written in the currentactivePart\n  // when a sign change happens to negative, the negative value gets written in the negativePart,\n  // but also the negativePart needs the 0 in it entered for the xBefore\n  //\n  // It always hits the 0, it never jumps directly to negative values!\n  // If it hits the 0 and the next value has a different sign, then the 0 gets written in both parts.\n\n\n  let positiveSeries = [];\n  let negativeSeries = [];\n\n  seriesData.forEach((series) => {\n\n    let data = series.data;\n    let positiveData = [];\n    let negativeData = [];\n\n    let activePart = positiveData;\n\n    for(let i=0, len=data.length; i<len; i++) {\n      let point = data[i];\n      let y = data[i].y;\n\n      if(y > 0) {\n        positiveData.push(point);\n        activePart = positiveData;\n      }\n      if(y < 0) {\n        negativeData.push(point);\n        activePart = negativeData;\n      }\n      if(y === 0) {\n        //ignore when first or last entry\n        if(i > 0 && i < len-1) {\n          let yBefore = data[i-1].y;\n          let yAfter= data[i+1].y;\n          if(Math.sign(yBefore) !== Math.sign(yAfter)) {\n            // push to both parts, when 0 is followed by a sign change\n            // but disable the tooltip for one\n            positiveData.push(point);\n            negativeData.push({\n              ...point, //spread operator\n              noTooltip: true\n            });\n          } else {\n            // if no sign change, just push to current active part\n            activePart.push(point);\n          }\n        } else {\n          // if 0 is first or last value it gets pushed to the current active part.\n          // activePart is positiveData for i==0\n          activePart.push(point);\n        }\n      }\n    }\n\n    positiveSeries.push({\n      name: series.name,\n      type: 'area',\n      id: series.id ? series.id : series.name,\n      data: positiveData,\n      stack: 'positive',\n      color: series.color ? series.color : undefined\n    });\n\n    negativeSeries.push({\n      name: series.name,\n      type: 'area',\n      linkedTo: series.id,\n      id: series.id ? series.id +'neg' : series.name +'neg', //id also necessary for negative series (for animated data update) I guess\n      data: negativeData,\n      stack: 'negative',\n      color: series.color ? series.color : undefined\n    });\n\n  });\n\n  return [positiveSeries, negativeSeries];\n}\n"]}]}