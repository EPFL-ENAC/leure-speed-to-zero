{"remainingRequest":"/Users/paruta/2050-Calculators/PCalc/transition-pathway-explorer/node_modules/babel-loader/lib/index.js!/Users/paruta/2050-Calculators/PCalc/transition-pathway-explorer/node_modules/eslint-loader/index.js??ref--13-0!/Users/paruta/2050-Calculators/PCalc/transition-pathway-explorer/src/routeService.js","dependencies":[{"path":"/Users/paruta/2050-Calculators/PCalc/transition-pathway-explorer/src/routeService.js","mtime":1707210098284},{"path":"/Users/paruta/2050-Calculators/PCalc/transition-pathway-explorer/node_modules/cache-loader/dist/cjs.js","mtime":1707234519865},{"path":"/Users/paruta/2050-Calculators/PCalc/transition-pathway-explorer/node_modules/babel-loader/lib/index.js","mtime":1707234519797},{"path":"/Users/paruta/2050-Calculators/PCalc/transition-pathway-explorer/node_modules/eslint-loader/index.js","mtime":1707234519720}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport page from 'page';\nimport * as dataService from \"./dataService.js\";\nimport * as outputsService from \"./outputsService.js\";\nimport * as inputsService from \"./inputsService.js\";\nimport { appState } from \"./dataService.js\";\nvar shouldFetch = true; //default\n\nfunction compareQueryParameters(qs1, qs2) {\n  // compares the parameters of two query strings, doesn't directly compare the strings with each other,\n  // because the order of parameters might be different, which is irrellevant when one wants to know\n  // if the parameters match.\n\n  var params1 = new URLSearchParams(qs1);\n  var params2 = new URLSearchParams(qs2);\n  var matching = true;\n\n  // params.keys() returns an iterator\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n  try {\n    for (var _iterator = params1.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var p = _step.value;\n      if (!params2.has(p) || params2.get(p) !== params1.get(p)) {\n        matching = false;\n        break;\n      }\n    }\n\n    //need to be done for second paramset, because the params1 might be shorter than param2\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n  try {\n    for (var _iterator2 = params2.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _p = _step2.value;\n      // console.log('params2 p ', p);\n      if (!params1.has(_p) || params1.get(_p) !== params2.get(_p)) {\n        matching = false;\n        break;\n      }\n    }\n\n    // console.log('matching ', matching);\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n  return matching;\n}\nexport function getURLParams(queryString, paramsToLookFor) {\n  //console.log(leverData.levers);\n  var results = {};\n  var urlParams = new URLSearchParams(queryString);\n  paramsToLookFor.forEach(function (name) {\n    var param = urlParams.get(name);\n    if (param) {\n      results[name] = param;\n    }\n  });\n  return results;\n}\nexport function initRoutes() {\n  /*set up routes*/\n  page('/', routeHome);\n  // page('/welcome', routeWelcome);\n  page('/intro', routeIntro);\n  // page('/intro/:screen', routeIntroScreen);\n  page('/budget', routeBudget);\n  page('/legal', routeLegal);\n  page('/app', routeCalculator);\n  page('/app/:tab', routeTab);\n  page('/app/:tab/:subtab', routeSubtab);\n  page('*', routeNotFound);\n\n  //activating\n  page();\n}\n\n// export function toggleFetching(_shouldFetch) {\n//   shouldFetch = _shouldFetch;\n// }\n\nvar routeHome = function routeHome() {\n  page.redirect('/intro');\n};\nvar routeCalculator = function routeCalculator() {\n  // redirect to first subtab\n  var tabIndex = 0;\n  var routeOfFirstTab = outputsService.tabRoutes[tabIndex].route;\n  var routeOfFirstSubtab = outputsService.tabRoutes[tabIndex][0].route;\n  if (routeOfFirstSubtab) {\n    page.redirect('/app/' + routeOfFirstTab + '/' + routeOfFirstSubtab);\n  }\n};\nvar routeIntro = function routeIntro() {\n  appState.mode = 'intro';\n};\nvar routeBudget = function routeBudget() {\n  appState.mode = 'target';\n  appState.menuOpen = false;\n};\nvar routeLegal = function routeLegal() {\n  //console.log('routeLegal');\n  appState.mode = 'legal';\n  appState.menuOpen = false;\n};\nvar routeTab = function routeTab(context) {\n  //redirects to the first subtab, defaults to the first tab if given tab from the URL doesn't exist\n  //find the name of the first subtab and redirect to that route\n  var tabname = context.params.tab;\n\n  //load first tab by default, if tabname is not found (bad url)\n  var tabIndex = outputsService.routes[tabname] ? outputsService.routes[tabname].index : 0;\n  var routeOfTab = outputsService.tabRoutes[tabIndex].route;\n  var routeOfFirstSubtab = outputsService.tabRoutes[tabIndex][0].route;\n  if (routeOfFirstSubtab) {\n    page.redirect('/app/' + routeOfTab + '/' + routeOfFirstSubtab);\n  }\n};\nvar routeSubtab = function routeSubtab(context) {\n  // during routing:\n  // 1. appState is set according to url-parameters\n  //    during that step the app-state is adapted if the parameters are invalid\n  //    or if levers are eu-only-values\n  // 2. at the end of the route process the querystring gets updated to the actual app-state\n\n  // window.location.search is empty in some cases, use context.querystring instead\n\n  // setTimeout(()=> {\n  console.log('routeSubtab ', appState);\n\n  //check context, correct to default values for routeOfTab and routeOfSubtab if necessary\n  var tabname = context.params.tab;\n  //load first tab by default, if tabname is not found (bad url)\n  var tabIndex = outputsService.routes[tabname] ? outputsService.routes[tabname].index : 0;\n  var routeOfTab = outputsService.tabRoutes[tabIndex].route;\n  var subtabname = context.params.subtab;\n  //load first subtab by default, if subtabname is not found (bad url)\n  var subtabIndex = outputsService.routes[routeOfTab][subtabname] ? outputsService.routes[routeOfTab][subtabname].index : 0;\n  // let routeOfSubtab = outputsService.tabRoutes[tabIndex][subtabIndex].route;\n\n  appState.mode = 'main';\n  appState.menuOpen = false;\n\n  // compare current route params with params of old state:\n  // this is only necessary in routeSubtab\n  var routeQuerystring = context.querystring; //works\n  var appStateQuerystring = appState.mainScreenRouteString.indexOf('?') > -1 ? appState.mainScreenRouteString.substring(appState.mainScreenRouteString.indexOf('?')) : \"\";\n\n  // paramsMatch is also true if both queryStrings are empty\n  var paramsMatch = compareQueryParameters(routeQuerystring, appStateQuerystring);\n\n  //check tab and subtab from URL against those in appState\n  var tabMatches; //subtab doesn't matter, a change in a subtab doesn't trigger a fetch\n  if (appState.activeTab !== null && appState.activeTab === tabIndex) {\n    tabMatches = true;\n  }\n\n  // If the old and new querystrings didn't match, set all parameters again, even if only one might be different\n  // resetting the whole state instead of changing it is a bit less efficient, but safer and less prone to bugs\n  //--> disadvantage: prefetching a subtab is impossible, because it would start a new fetch here, because the URLs didn't match\n\n  //urlParameters are needed regardless of paramsMatch\n  var urlParameters = getURLParams(routeQuerystring, ['levers', 'other', 'country']);\n\n  // when navigating from main-screen to budget and back to mainscreen,\n  // urlParameters exists but the params already match (Object.keys(urlParameters).length > 0, paramsMatch == true)\n  // --> in that case nothing happens\n  // if there are params and they don't match with the appState\n  if (Object.keys(urlParameters).length && !paramsMatch) {\n    // setInputsFromURLParameters() checks if parameters are valid and applies fallback settings if not\n    inputsService.setInputsFromURLParameters(urlParameters.levers, urlParameters.other, urlParameters.country);\n  } else if (!Object.keys(urlParameters).length) {\n    // load the first example pathway if there are no parameters set\n    inputsService.setExamplePathway(0);\n  }\n  outputsService.selectTab(tabIndex, subtabIndex, false);\n\n  // Automatic zoom into a country is deactivated for now,\n  // because even when just clicking away from the MainScreen and back to it, it would zoom into a country\n  // if a country is zoomed into would need to be a URL parameter to avoid that case\n  // if(urlParameters.other && urlParameters.country) {\n  //   outputsService.setCountryZoom(1); //zoom into that country, if subtab-component supports it\n  // }\n\n  // checkIfLeversMatchExamplePathway also sets appState.pathwayIndex if any was found and that sets the pathway select-input\n  var matchesWithExamplePathway;\n  matchesWithExamplePathway = inputsService.checkIfLeversMatchExamplePathway();\n  if (appState.onlyExamplePathwayRoutes && !matchesWithExamplePathway) {\n    // if in examplePathwaysOnly-mode and the user changed the url to a\n    // non-valid pathway (non-examplePathway), then redirect to home-route\n    // resetting to the first examplePathway is difficult, because also\n    // any single-country-levers-settings would need to get corrected\n    // resetting all state is tedious for this edge case, so just trigger a hard reload:\n    document.location.replace(document.location.origin);\n    // page.redirect('/app'); /doesn't work because old appState will still be present\n    return; //not necessary actually\n  }\n\n  // important: update the appState.mainScreenRouteString (after setting all state inside the app)\n  // create the routeString from app data, not from window.location.pathname,\n  // because the URL might be bad and the tabs might have been corrected to valid ones\n  var routeString = dataService.createRouteString();\n  appState.mainScreenRouteString = routeString;\n  // console.log('routeString ', routeString)\n\n  // DONT call history.pushState, use history.replaceState to correct or complete the URL (matching it against the appState)\n  // Always work with full a URL that reflects the appState's get parameters, this is important when working with the\n  // browser-history, so that when a user clicks back or forward, the URL always contains all necessary information to\n  // rebuild the appState. Additional info that is not stored in the URL can optionally be stored in the history's stateObj\n  // (like appState.countryZoom for instance (this is not implemented))\n  history.replaceState({\n    path: appState.mainScreenRouteString\n  }, null, appState.mainScreenRouteString);\n  // history.pushState({path: appState.mainScreenRouteString}, null, appState.mainScreenRouteString);\n\n  // console.log('routeSubtab ', paramsMatch, tabMatches);\n  if ((!paramsMatch || !tabMatches) && shouldFetch) {\n    console.log('routeSubtab fetching');\n\n    // reset user actions before fetch (otherwise it would zoom into a selected country by default)\n    appState.userAction = [];\n    dataService.fetchData();\n  }\n  // },0);\n};\nvar routeNotFound = function routeNotFound() {\n  console.log('routeNotFound');\n  page.redirect('/');\n};",{"version":3,"names":["page","dataService","outputsService","inputsService","appState","shouldFetch","compareQueryParameters","qs1","qs2","params1","URLSearchParams","params2","matching","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","keys","Symbol","iterator","_step","next","done","p","value","has","get","err","return","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","getURLParams","queryString","paramsToLookFor","results","urlParams","forEach","name","param","initRoutes","routeHome","routeIntro","routeBudget","routeLegal","routeCalculator","routeTab","routeSubtab","routeNotFound","redirect","tabIndex","routeOfFirstTab","tabRoutes","route","routeOfFirstSubtab","mode","menuOpen","context","tabname","params","tab","routes","index","routeOfTab","console","log","subtabname","subtab","subtabIndex","routeQuerystring","querystring","appStateQuerystring","mainScreenRouteString","indexOf","substring","paramsMatch","tabMatches","activeTab","urlParameters","Object","length","setInputsFromURLParameters","levers","other","country","setExamplePathway","selectTab","matchesWithExamplePathway","checkIfLeversMatchExamplePathway","onlyExamplePathwayRoutes","document","location","replace","origin","routeString","createRouteString","history","replaceState","path","userAction","fetchData"],"sources":["/Users/paruta/2050-Calculators/PCalc/transition-pathway-explorer/src/routeService.js"],"sourcesContent":["import page from 'page';\n\nimport * as dataService from './dataService.js';\nimport * as outputsService from './outputsService.js';\nimport * as inputsService from './inputsService.js';\n\nimport {appState} from './dataService.js';\n\nvar shouldFetch = true; //default\n\nfunction compareQueryParameters(qs1,qs2) {\n  // compares the parameters of two query strings, doesn't directly compare the strings with each other,\n  // because the order of parameters might be different, which is irrellevant when one wants to know\n  // if the parameters match.\n\n  let params1 = new URLSearchParams(qs1);\n  let params2 = new URLSearchParams(qs2);\n\n  let matching = true;\n\n  // params.keys() returns an iterator\n  for(let p of params1.keys()) {\n    if(!params2.has(p) || params2.get(p) !== params1.get(p)) {\n      matching = false;\n      break;\n    }\n  }\n\n  //need to be done for second paramset, because the params1 might be shorter than param2\n  for(let p of params2.keys()) {\n    // console.log('params2 p ', p);\n    if(!params1.has(p) || params1.get(p) !== params2.get(p)) {\n      matching = false;\n      break;\n    }\n  }\n\n  // console.log('matching ', matching);\n  return matching;\n}\n\n\nexport function getURLParams(queryString, paramsToLookFor) {\n  //console.log(leverData.levers);\n  var results = {};\n\n  const urlParams = new URLSearchParams(queryString);\n  paramsToLookFor.forEach((name)=> {\n    let param = urlParams.get(name);\n    if(param) {\n      results[name] = param;\n    }\n  });\n\n  return results;\n}\n\nexport function initRoutes() {\n  /*set up routes*/\n  page('/', routeHome);\n  // page('/welcome', routeWelcome);\n  page('/intro', routeIntro);\n  // page('/intro/:screen', routeIntroScreen);\n  page('/budget', routeBudget);\n  page('/legal', routeLegal);\n  page('/app', routeCalculator);\n  page('/app/:tab', routeTab);\n  page('/app/:tab/:subtab', routeSubtab);\n  page('*', routeNotFound);\n\n  //activating\n  page();\n}\n\n// export function toggleFetching(_shouldFetch) {\n//   shouldFetch = _shouldFetch;\n// }\n\n\nvar routeHome = function() {\n  page.redirect('/intro');\n};\n\nvar routeCalculator = function() {\n  // redirect to first subtab\n  let tabIndex = 0;\n  let routeOfFirstTab = outputsService.tabRoutes[tabIndex].route;\n\n  let routeOfFirstSubtab = outputsService.tabRoutes[tabIndex][0].route\n\n  if(routeOfFirstSubtab) {\n    page.redirect('/app/'+routeOfFirstTab+'/'+routeOfFirstSubtab);\n  }\n};\n\nvar routeIntro = function() {\n  appState.mode = 'intro';\n};\n\nvar routeBudget = function() {\n  appState.mode = 'target';\n  appState.menuOpen = false;\n};\n\nvar routeLegal = function() {\n  //console.log('routeLegal');\n  appState.mode = 'legal';\n  appState.menuOpen = false;\n};\n\nvar routeTab = function(context) {\n\n  //redirects to the first subtab, defaults to the first tab if given tab from the URL doesn't exist\n  //find the name of the first subtab and redirect to that route\n  let tabname = context.params.tab;\n\n  //load first tab by default, if tabname is not found (bad url)\n  let tabIndex = outputsService.routes[tabname] ? outputsService.routes[tabname].index : 0;\n  let routeOfTab = outputsService.tabRoutes[tabIndex].route;\n\n\n  let routeOfFirstSubtab = outputsService.tabRoutes[tabIndex][0].route\n\n  if(routeOfFirstSubtab) {\n    page.redirect('/app/'+routeOfTab+'/'+routeOfFirstSubtab);\n  }\n\n};\n\nvar routeSubtab = function(context) {\n  // during routing:\n  // 1. appState is set according to url-parameters\n  //    during that step the app-state is adapted if the parameters are invalid\n  //    or if levers are eu-only-values\n  // 2. at the end of the route process the querystring gets updated to the actual app-state\n\n  // window.location.search is empty in some cases, use context.querystring instead\n\n  // setTimeout(()=> {\n    console.log('routeSubtab ', appState);\n\n    //check context, correct to default values for routeOfTab and routeOfSubtab if necessary\n    let tabname = context.params.tab;\n    //load first tab by default, if tabname is not found (bad url)\n    let tabIndex = outputsService.routes[tabname] ? outputsService.routes[tabname].index : 0;\n    let routeOfTab = outputsService.tabRoutes[tabIndex].route;\n\n    let subtabname = context.params.subtab;\n    //load first subtab by default, if subtabname is not found (bad url)\n    let subtabIndex = outputsService.routes[routeOfTab][subtabname] ? outputsService.routes[routeOfTab][subtabname].index : 0;\n    // let routeOfSubtab = outputsService.tabRoutes[tabIndex][subtabIndex].route;\n\n    appState.mode = 'main';\n    appState.menuOpen = false;\n\n    // compare current route params with params of old state:\n    // this is only necessary in routeSubtab\n    let routeQuerystring = context.querystring; //works\n    let appStateQuerystring = appState.mainScreenRouteString.indexOf('?') > -1 ? appState.mainScreenRouteString.substring(appState.mainScreenRouteString.indexOf('?')) : \"\";\n\n    // paramsMatch is also true if both queryStrings are empty\n    let paramsMatch = compareQueryParameters(routeQuerystring, appStateQuerystring);\n\n    //check tab and subtab from URL against those in appState\n    let tabMatches; //subtab doesn't matter, a change in a subtab doesn't trigger a fetch\n    if(appState.activeTab !== null && appState.activeTab === tabIndex) {\n      tabMatches = true;\n    }\n\n    // If the old and new querystrings didn't match, set all parameters again, even if only one might be different\n    // resetting the whole state instead of changing it is a bit less efficient, but safer and less prone to bugs\n    //--> disadvantage: prefetching a subtab is impossible, because it would start a new fetch here, because the URLs didn't match\n\n    //urlParameters are needed regardless of paramsMatch\n    let urlParameters = getURLParams(routeQuerystring, ['levers', 'other', 'country']);\n\n    // when navigating from main-screen to budget and back to mainscreen,\n    // urlParameters exists but the params already match (Object.keys(urlParameters).length > 0, paramsMatch == true)\n    // --> in that case nothing happens\n    // if there are params and they don't match with the appState\n    if(Object.keys(urlParameters).length && !paramsMatch) {\n\n      // setInputsFromURLParameters() checks if parameters are valid and applies fallback settings if not\n      inputsService.setInputsFromURLParameters(urlParameters.levers, urlParameters.other, urlParameters.country);\n\n    } else if(!Object.keys(urlParameters).length) {\n      // load the first example pathway if there are no parameters set\n      inputsService.setExamplePathway(0);\n    }\n\n    outputsService.selectTab(tabIndex,subtabIndex,false);\n\n    // Automatic zoom into a country is deactivated for now,\n    // because even when just clicking away from the MainScreen and back to it, it would zoom into a country\n    // if a country is zoomed into would need to be a URL parameter to avoid that case\n    // if(urlParameters.other && urlParameters.country) {\n    //   outputsService.setCountryZoom(1); //zoom into that country, if subtab-component supports it\n    // }\n\n    // checkIfLeversMatchExamplePathway also sets appState.pathwayIndex if any was found and that sets the pathway select-input\n    let matchesWithExamplePathway;\n    matchesWithExamplePathway = inputsService.checkIfLeversMatchExamplePathway();\n\n    if(appState.onlyExamplePathwayRoutes && !matchesWithExamplePathway) {\n      // if in examplePathwaysOnly-mode and the user changed the url to a\n      // non-valid pathway (non-examplePathway), then redirect to home-route\n      // resetting to the first examplePathway is difficult, because also\n      // any single-country-levers-settings would need to get corrected\n      // resetting all state is tedious for this edge case, so just trigger a hard reload:\n      document.location.replace(document.location.origin);\n      // page.redirect('/app'); /doesn't work because old appState will still be present\n      return; //not necessary actually\n    }\n\n    // important: update the appState.mainScreenRouteString (after setting all state inside the app)\n    // create the routeString from app data, not from window.location.pathname,\n    // because the URL might be bad and the tabs might have been corrected to valid ones\n    let routeString = dataService.createRouteString();\n\n    appState.mainScreenRouteString = routeString;\n    // console.log('routeString ', routeString)\n\n    // DONT call history.pushState, use history.replaceState to correct or complete the URL (matching it against the appState)\n    // Always work with full a URL that reflects the appState's get parameters, this is important when working with the\n    // browser-history, so that when a user clicks back or forward, the URL always contains all necessary information to\n    // rebuild the appState. Additional info that is not stored in the URL can optionally be stored in the history's stateObj\n    // (like appState.countryZoom for instance (this is not implemented))\n    history.replaceState({path: appState.mainScreenRouteString}, null, appState.mainScreenRouteString);\n    // history.pushState({path: appState.mainScreenRouteString}, null, appState.mainScreenRouteString);\n\n    // console.log('routeSubtab ', paramsMatch, tabMatches);\n    if((!paramsMatch || !tabMatches) && shouldFetch) {\n      console.log('routeSubtab fetching');\n\n      // reset user actions before fetch (otherwise it would zoom into a selected country by default)\n      appState.userAction = [];\n      dataService.fetchData();\n    }\n  // },0);\n};\n\nvar routeNotFound = function() {\n  console.log('routeNotFound');\n  page.redirect('/');\n}\n"],"mappings":"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"}]}