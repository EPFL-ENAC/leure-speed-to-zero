{"remainingRequest":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/babel-loader/lib/index.js!/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/cache-loader/dist/cjs.js??ref--0-0!/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/src/lib/TabNavigation.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/src/lib/TabNavigation.vue","mtime":1707210098283},{"path":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/cache-loader/dist/cjs.js","mtime":1707234519865},{"path":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/babel-loader/lib/index.js","mtime":1707234519797},{"path":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/cache-loader/dist/cjs.js","mtime":1707234519865},{"path":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/vue-loader/lib/index.js","mtime":1707234519986}],"contextDependencies":[],"result":["import \"core-js/modules/web.dom.iterable\";\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n// needs the outputsService for the tabsWithWarnings\nimport * as outputsService from \"../outputsService.js\";\nexport default {\n  name: 'TabNavigation',\n  props: ['tabs', 'tabIndex', 'callback'],\n  data: function data() {\n    return {\n      paginationNeeded: undefined,\n      noTransition: true,\n      holderPos: undefined,\n      containerWidth: undefined,\n      holderWidth: undefined,\n      isLeftDirection: undefined,\n      tabsWithWarnings: outputsService.tabsWithWarnings\n    };\n  },\n  methods: {\n    selectTab: function selectTab(index) {\n      clearTimeout(this.panTimerId);\n\n      if (index < this.tabIndex) {\n        this.isLeftDirection = true;\n      } else {\n        this.isLeftDirection = false;\n      } // check wether item is fully visible, if not make it fully visible\n\n\n      var item = this.tabItems[index]; // item was clicked, so no need to check weather it is inside the visible portion\n\n      if (item.left < this.holderPos) {\n        if (index === 0) {\n          this.holderPos = 0;\n        } else {\n          this.holderPos = item.left;\n        }\n      }\n\n      if (item.right > this.holderPos + this.containerWidth) {\n        this.holderPos = item.right - this.containerWidth;\n      }\n\n      this.activeHolderPos = this.holderPos;\n      this.callback(index);\n    },\n    autoPanBack: function autoPanBack() {\n      var _this = this;\n\n      clearTimeout(this.panTimerId);\n      this.panTimerId = setTimeout(function () {\n        _this.holderPos = _this.activeHolderPos;\n      }, 4000);\n    },\n    updateActiveHolderPos: function updateActiveHolderPos() {\n      // check if active item is still visible\n      var itemLeft = this.tabItems[this.tabIndex].left;\n      var itemRight = this.tabItems[this.tabIndex].right;\n      var holderLeft = this.holderPos;\n      var holderRight = this.holderPos + this.containerWidth;\n\n      if (itemLeft > holderLeft && itemLeft < holderRight || itemRight > holderLeft && itemRight < holderRight) {\n        this.activeHolderPos = this.holderPos;\n      }\n    },\n    goBack: function goBack() {\n      this.autoPanBack();\n      var newStartingItem; // find first item, that starts on the left side of current portion\n\n      for (var i = this.tabItems.length - 1; i >= 0; i--) {\n        if (this.tabItems[i].left < this.holderPos) {\n          newStartingItem = this.tabItems[i];\n          break;\n        }\n      }\n\n      if (!newStartingItem) {\n        return;\n      }\n\n      if (newStartingItem.right >= this.containerWidth) {\n        this.holderPos = newStartingItem.right - this.containerWidth;\n      } else {\n        this.holderPos = 0;\n      }\n\n      this.updateActiveHolderPos();\n    },\n    goForward: function goForward() {\n      var _this2 = this;\n\n      this.autoPanBack(); // find the next element which rightPosition is bigger than holderPos,\n      // make this elements leftPos the new holderPos if the remaining space is bigger than containerWidth\n      // if remaining space is smaller\n\n      var newStartingItem; // Array.find() not supported by Internet Explorer\n\n      this.tabItems.some(function (item) {\n        if (item.right > _this2.holderPos + _this2.containerWidth) {\n          newStartingItem = item;\n          return true;\n        }\n      });\n\n      if (!newStartingItem) {\n        return;\n      }\n\n      if (newStartingItem.remainingSpace >= this.containerWidth) {\n        this.holderPos = newStartingItem.left;\n      } else {\n        this.holderPos = this.holderWidth - this.containerWidth;\n      }\n\n      this.updateActiveHolderPos();\n    },\n    getPositions: function getPositions() {\n      var _this3 = this;\n\n      this.tabItems = [];\n\n      if (this.$refs.container) {\n        this.containerWidth = this.$refs.container.getBoundingClientRect().width;\n      } // if pagination is needed but the pagination-arrows are not rendered yet\n\n\n      if (!this.$refs.arrow && this.paginationNeeded) {\n        this.containerWidth -= this.paginationWidth;\n      }\n\n      var itemLeft = 0;\n      this.$refs.tab.forEach(function (tab, ind) {\n        var itemWidth = tab.getBoundingClientRect().width;\n        var itemMarginLeft = parseInt(window.getComputedStyle(tab).getPropertyValue('margin-left'));\n        var itemMarginRight = parseInt(window.getComputedStyle(tab).getPropertyValue('margin-right'));\n        itemWidth += itemMarginLeft + itemMarginRight;\n\n        _this3.tabItems.push({\n          left: itemLeft,\n          width: itemWidth,\n          right: itemLeft + itemWidth,\n          title: _this3.tabs[ind].title,\n          remainingSpace: _this3.holderWidth - itemLeft\n        });\n\n        itemLeft += itemWidth;\n      });\n    },\n    findPosOfActiveTab: function findPosOfActiveTab() {\n      // go find in which portion the activeTab starts\n      // if it ends in the next portion add the difference in px\n      // check if activeTab is fully inside one portion\n      var numPortions = Math.ceil(this.holderWidth / this.containerWidth);\n      var leftOfActive = this.tabItems[this.tabIndex].left;\n      var rightOfActive = this.tabItems[this.tabIndex].right;\n\n      for (var i = 1; i <= numPortions; i++) {\n        if (leftOfActive < this.containerWidth * i) {\n          if (i < numPortions) {\n            this.holderPos = this.containerWidth * (i - 1); // before last Portion, overlap possible\n\n            if (rightOfActive > this.containerWidth * i) {\n              // if active Element overlaps its portion, add the overlap to the holderPos\n              this.holderPos += rightOfActive - this.containerWidth * i;\n            }\n          }\n\n          if (i === numPortions) {\n            // last Portion, no overlap possible\n            // the last portion can be smaller than the containerWidth, so this assignment is safe:\n            this.holderPos = this.holderWidth - this.containerWidth;\n          }\n\n          break;\n        }\n      }\n\n      this.activeHolderPos = this.holderPos;\n    },\n    checkPagination: function checkPagination() {\n      this.paginationNeeded = false;\n\n      if (this.$refs.holder) {\n        this.holderWidth = this.$refs.holder.getBoundingClientRect().width;\n      }\n\n      if (this.$refs.tabnav.getBoundingClientRect().width < this.holderWidth) {\n        this.paginationNeeded = true;\n      }\n    },\n    showTabs: function showTabs() {\n      var _this4 = this;\n\n      window.requestAnimationFrame(function () {\n        window.requestAnimationFrame(function () {\n          _this4.noTransition = false;\n        });\n      });\n    },\n    redraw: function redraw() {\n      var _this5 = this;\n\n      // only redraw when resizing is complete, not on every single resize event\n      clearTimeout(this.timerId);\n      this.timerId = setTimeout(function () {\n        _this5.checkPagination();\n\n        if (_this5.paginationNeeded) {\n          _this5.getPositions();\n\n          _this5.findPosOfActiveTab();\n        } else {\n          // reset to beginning if no pagination needed\n          _this5.holderPos = 0;\n\n          _this5.getPositions();\n        }\n      }, 100);\n    }\n  },\n  created: function created() {\n    // needed for automatically panning back after inactivity after scrolling\n    this.activeHolderPos = undefined;\n    this.panTimerId = undefined; // hardcoded, well..\n\n    this.paginationWidth = 40;\n    this.timerId = undefined;\n    window.addEventListener('resize', this.redraw);\n  },\n  mounted: function mounted() {\n    this.checkPagination();\n    this.getPositions();\n    this.findPosOfActiveTab();\n    this.showTabs();\n  },\n  beforeDestroy: function beforeDestroy() {\n    window.removeEventListener('resize', this.redraw);\n  }\n};",{"version":3,"sources":["TabNavigation.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\n  <div class=\"tab-nav\" ref=\"tabnav\">\n\n    <div v-if=\"paginationNeeded\" ref=\"arrow\">\n      <div class=\"tab-nav-arrow tn-left\"\n        :class=\"{'tn-active': holderPos!==0}\" v-on:click=\"goBack\"\n      >\n        <img src=\"/img/arrow-left.svg\">\n      </div>\n      <div class=\"tab-nav-arrow tn-right\"\n        v-if=\"paginationNeeded\"\n        :class=\"{'tn-active': holderPos < holderWidth-containerWidth}\" v-on:click=\"goForward\"\n      >\n        <img src=\"/img/arrow-right.svg\">\n      </div>\n    </div>\n\n    <div class=\"tab-nav-cont\" ref=\"container\" :class=\"{'tn-paginated': paginationNeeded}\">\n\n      <div class=\"tab-nav-holder\" ref=\"holder\"\n        :class=\"{'tn-inactive': noTransition}\"\n        :style=\"{transform: 'translateX(-'+holderPos+'px)'}\"\n      >\n        <span v-for=\"(tab,index) in tabs\" ref=\"tab\" :key=\"tab.title\" class=\"tab-item\"\n          :class=\"{\n            selected:tabIndex===index,\n            'tn-left': tabIndex===index && isLeftDirection,\n            'tn-right': tabIndex===index && !isLeftDirection,\n          }\"\n          v-on:click=\"selectTab(index)\"\n        >\n          <div class=\"tab-item-title\">\n            <span>{{tab.title}}</span>\n            <span v-if=\"tabsWithWarnings.indexOf(tab.route) >= 0\" class=\"tab-item-warning\">!</span>\n          </div>\n        </span>\n      </div>\n\n    </div>\n\n  </div>\n</template>\n\n<script>\n// needs the outputsService for the tabsWithWarnings\nimport * as outputsService from '../outputsService.js';\n\nexport default {\n  name: 'TabNavigation',\n  props: ['tabs', 'tabIndex', 'callback'],\n  data() {\n    return {\n      paginationNeeded: undefined,\n      noTransition: true,\n      holderPos: undefined,\n      containerWidth: undefined,\n      holderWidth: undefined,\n      isLeftDirection: undefined,\n      tabsWithWarnings: outputsService.tabsWithWarnings\n    }\n  },\n  methods: {\n    selectTab(index) {\n      clearTimeout(this.panTimerId);\n\n      if(index < this.tabIndex) {\n        this.isLeftDirection = true;\n      } else {\n        this.isLeftDirection = false;\n      }\n\n      // check wether item is fully visible, if not make it fully visible\n      let item = this.tabItems[index];\n\n      // item was clicked, so no need to check weather it is inside the visible portion\n      if(item.left < this.holderPos) {\n        if(index === 0) {\n          this.holderPos = 0;\n        } else {\n          this.holderPos = item.left\n        }\n      }\n\n      if(item.right > this.holderPos + this.containerWidth) {\n        this.holderPos = item.right - this.containerWidth;\n      }\n\n      this.activeHolderPos = this.holderPos;\n      this.callback(index);\n\n    },\n    autoPanBack() {\n      clearTimeout(this.panTimerId);\n      this.panTimerId = setTimeout(() => {\n        this.holderPos = this.activeHolderPos;\n      }, 4000);\n    },\n    updateActiveHolderPos() {\n      // check if active item is still visible\n      let itemLeft = this.tabItems[this.tabIndex].left;\n      let itemRight = this.tabItems[this.tabIndex].right;\n      let holderLeft = this.holderPos;\n      let holderRight = this.holderPos + this.containerWidth;\n      if(\n          (itemLeft > holderLeft && itemLeft < holderRight) ||\n          (itemRight > holderLeft && itemRight < holderRight)\n        ) {\n            this.activeHolderPos = this.holderPos;\n      }\n    },\n    goBack() {\n      this.autoPanBack();\n\n      let newStartingItem;\n\n      // find first item, that starts on the left side of current portion\n      for(let i=this.tabItems.length-1; i >= 0; i--) {\n        if(this.tabItems[i].left < this.holderPos) {\n          newStartingItem = this.tabItems[i];\n          break;\n        }\n      }\n\n      if(!newStartingItem) {\n        return;\n      }\n\n      if(newStartingItem.right >= this.containerWidth) {\n        this.holderPos = newStartingItem.right-this.containerWidth;\n      } else {\n        this.holderPos = 0;\n      }\n\n      this.updateActiveHolderPos();\n    },\n    goForward() {\n      this.autoPanBack();\n      // find the next element which rightPosition is bigger than holderPos,\n      // make this elements leftPos the new holderPos if the remaining space is bigger than containerWidth\n      // if remaining space is smaller\n      let newStartingItem;\n\n      // Array.find() not supported by Internet Explorer\n      this.tabItems.some((item) => {\n         if(item.right > this.holderPos + this.containerWidth) {\n           newStartingItem = item;\n           return true;\n         }\n      });\n\n      if(!newStartingItem) {\n        return;\n      }\n\n      if(newStartingItem.remainingSpace >= this.containerWidth) {\n        this.holderPos = newStartingItem.left;\n      } else {\n        this.holderPos = this.holderWidth - this.containerWidth;\n      }\n\n      this.updateActiveHolderPos();\n    },\n    getPositions() {\n      this.tabItems = [];\n\n      if(this.$refs.container) {\n        this.containerWidth = this.$refs.container.getBoundingClientRect().width;\n      }\n\n      // if pagination is needed but the pagination-arrows are not rendered yet\n      if(!this.$refs.arrow && this.paginationNeeded) {\n        this.containerWidth -= this.paginationWidth;\n      }\n\n      let itemLeft = 0;\n      this.$refs.tab.forEach((tab, ind) => {\n        let itemWidth = tab.getBoundingClientRect().width;\n        let itemMarginLeft = parseInt(window.getComputedStyle(tab).getPropertyValue('margin-left'));\n        let itemMarginRight = parseInt(window.getComputedStyle(tab).getPropertyValue('margin-right'));\n\n        itemWidth += itemMarginLeft + itemMarginRight;\n\n        this.tabItems.push({\n          left: itemLeft,\n          width: itemWidth,\n          right: itemLeft + itemWidth,\n          title: this.tabs[ind].title,\n          remainingSpace: this.holderWidth - itemLeft\n        });\n        itemLeft += itemWidth;\n      });\n    },\n    findPosOfActiveTab() {\n\n      // go find in which portion the activeTab starts\n      // if it ends in the next portion add the difference in px\n\n      // check if activeTab is fully inside one portion\n      let numPortions = Math.ceil(this.holderWidth / this.containerWidth);\n      let leftOfActive = this.tabItems[this.tabIndex].left;\n      let rightOfActive = this.tabItems[this.tabIndex].right;\n\n      for(let i=1; i<=numPortions; i++) {\n        if(leftOfActive < this.containerWidth*i) {\n          if(i<numPortions) {\n            this.holderPos = this.containerWidth*(i-1);\n            // before last Portion, overlap possible\n            if(rightOfActive > this.containerWidth*i) {\n              // if active Element overlaps its portion, add the overlap to the holderPos\n              this.holderPos += rightOfActive - this.containerWidth*i;\n            }\n          }\n          if(i === numPortions) {\n            // last Portion, no overlap possible\n            // the last portion can be smaller than the containerWidth, so this assignment is safe:\n            this.holderPos = this.holderWidth - this.containerWidth;\n          }\n\n          break;\n        }\n      }\n\n      this.activeHolderPos = this.holderPos;\n\n    },\n    checkPagination() {\n      this.paginationNeeded = false;\n      if(this.$refs.holder) {\n        this.holderWidth = this.$refs.holder.getBoundingClientRect().width;\n      }\n      if(this.$refs.tabnav.getBoundingClientRect().width < this.holderWidth) {\n        this.paginationNeeded = true;\n      }\n    },\n    showTabs() {\n      window.requestAnimationFrame(() => {\n        window.requestAnimationFrame(() => {\n          this.noTransition = false;\n        });\n      });\n    },\n    redraw() {\n      // only redraw when resizing is complete, not on every single resize event\n      clearTimeout(this.timerId);\n      this.timerId = setTimeout(() => {\n        this.checkPagination();\n        if(this.paginationNeeded) {\n          this.getPositions();\n          this.findPosOfActiveTab();\n        } else {\n          // reset to beginning if no pagination needed\n          this.holderPos = 0;\n          this.getPositions();\n        }\n      }, 100);\n    }\n  },\n  created() {\n    // needed for automatically panning back after inactivity after scrolling\n    this.activeHolderPos = undefined;\n\n    this.panTimerId = undefined;\n\n    // hardcoded, well..\n    this.paginationWidth = 40;\n\n    this.timerId = undefined;\n    window.addEventListener('resize', this.redraw);\n  },\n  mounted() {\n    this.checkPagination();\n    this.getPositions();\n    this.findPosOfActiveTab();\n    this.showTabs();\n  },\n  beforeDestroy() {\n    window.removeEventListener('resize', this.redraw);\n  }\n}\n</script>\n\n<style>\n.tab-nav {\n  width: 100%;\n  /*height needs to be set by containing element (outer container that holds this component)*/\n  height: 100%;\n  position: relative;\n  background-color: white;\n  overflow: hidden;\n}\n.tab-nav-arrow {\n  height: 100%;\n  width: 20px;\n  position: absolute;\n  top: 0px;\n  z-index: 10;\n}\n.tab-nav-arrow::after {\n  content: '';\n  position: absolute;\n  bottom: 0px;\n  left: 0px;\n  width: 100%;\n  height: 5px;\n  background-color: white;\n}\n.tab-nav-arrow.tn-left {\n  left: 0px;\n  background: linear-gradient(to right, rgba(255, 255, 255, 1) 0%, rgba(255, 255, 255, 1) 80%, rgba(255, 255, 255, 0) 100%);\n}\n.tab-nav-arrow.tn-right {\n  right: 0px;\n  background: linear-gradient(to right, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 1) 20%, rgba(255, 255, 255, 1) 100%);\n}\n.tab-nav-arrow img {\n  position: absolute;\n  height: 16px;\n  display: block;\n  top: 40%;\n  transform: translateY(-50%);\n  opacity: 0;\n  transition: opacity 0.3s ease;\n}\n.tab-nav-arrow.tn-right img {\n  right: 0px;\n}\n.tab-nav-arrow.tn-left img {\n  left: 0px;\n}\n.tab-nav-arrow.tn-active img {\n  opacity: 1;\n  cursor: pointer;\n}\n\n.tab-nav-cont {\n  /*can't use flex with flex-grow, because on page-load .tab-nav-cont doesn't take up full width,\n  only after 150ms it would. Use as normal block-div works,\n  but then the arrows need to use position absolute */\n  height: 100%;\n  margin: 0px;\n  position: relative;\n\n}\n.tab-nav-cont.tn-paginated {\n  margin: 0px 20px;\n}\n.tn-mask {\n  flex: none;\n  width: 10px;\n  align-self: stretch;\n  z-index: 2;\n  pointer-events: none;\n}\n.tn-mask-left {\n  background: linear-gradient(to right, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0));\n}\n.tn-mask-right {\n  background: linear-gradient(to right, rgba(255, 255, 255, 0), rgba(255, 255, 255, 1));\n}\n\n.tab-nav-holder {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  height: 100%;\n  display: flex;\n  align-items: center;\n  transition: transform 1s cubic-bezier(0.35, 0, 0.25, 1);\n}\n.tab-nav-holder.tn-inactive {\n  transition-duration: 0s;\n}\n\n</style>\n"],"sourceRoot":"src/lib"}]}