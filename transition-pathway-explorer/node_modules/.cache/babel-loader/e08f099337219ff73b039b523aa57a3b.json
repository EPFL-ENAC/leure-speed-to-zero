{"remainingRequest":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/babel-loader/lib/index.js!/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/cache-loader/dist/cjs.js??ref--0-0!/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/src/lib/TabNavigation.vue?vue&type=script&lang=js","dependencies":[{"path":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/src/lib/TabNavigation.vue","mtime":1707210098283},{"path":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/cache-loader/dist/cjs.js","mtime":1707234519865},{"path":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/babel-loader/lib/index.js","mtime":1707234519797},{"path":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/cache-loader/dist/cjs.js","mtime":1707234519865},{"path":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/vue-loader/lib/index.js","mtime":1707234682968}],"contextDependencies":[],"result":["import \"core-js/modules/web.dom.iterable\";\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n// needs the outputsService for the tabsWithWarnings\nimport * as outputsService from \"../outputsService.js\";\nexport default {\n  name: 'TabNavigation',\n  props: ['tabs', 'tabIndex', 'callback'],\n  data: function data() {\n    return {\n      paginationNeeded: undefined,\n      noTransition: true,\n      holderPos: undefined,\n      containerWidth: undefined,\n      holderWidth: undefined,\n      isLeftDirection: undefined,\n      tabsWithWarnings: outputsService.tabsWithWarnings\n    };\n  },\n  methods: {\n    selectTab: function selectTab(index) {\n      clearTimeout(this.panTimerId);\n      if (index < this.tabIndex) {\n        this.isLeftDirection = true;\n      } else {\n        this.isLeftDirection = false;\n      }\n\n      // check wether item is fully visible, if not make it fully visible\n      var item = this.tabItems[index];\n\n      // item was clicked, so no need to check weather it is inside the visible portion\n      if (item.left < this.holderPos) {\n        if (index === 0) {\n          this.holderPos = 0;\n        } else {\n          this.holderPos = item.left;\n        }\n      }\n      if (item.right > this.holderPos + this.containerWidth) {\n        this.holderPos = item.right - this.containerWidth;\n      }\n      this.activeHolderPos = this.holderPos;\n      this.callback(index);\n    },\n    autoPanBack: function autoPanBack() {\n      var _this = this;\n      clearTimeout(this.panTimerId);\n      this.panTimerId = setTimeout(function () {\n        _this.holderPos = _this.activeHolderPos;\n      }, 4000);\n    },\n    updateActiveHolderPos: function updateActiveHolderPos() {\n      // check if active item is still visible\n      var itemLeft = this.tabItems[this.tabIndex].left;\n      var itemRight = this.tabItems[this.tabIndex].right;\n      var holderLeft = this.holderPos;\n      var holderRight = this.holderPos + this.containerWidth;\n      if (itemLeft > holderLeft && itemLeft < holderRight || itemRight > holderLeft && itemRight < holderRight) {\n        this.activeHolderPos = this.holderPos;\n      }\n    },\n    goBack: function goBack() {\n      this.autoPanBack();\n      var newStartingItem;\n\n      // find first item, that starts on the left side of current portion\n      for (var i = this.tabItems.length - 1; i >= 0; i--) {\n        if (this.tabItems[i].left < this.holderPos) {\n          newStartingItem = this.tabItems[i];\n          break;\n        }\n      }\n      if (!newStartingItem) {\n        return;\n      }\n      if (newStartingItem.right >= this.containerWidth) {\n        this.holderPos = newStartingItem.right - this.containerWidth;\n      } else {\n        this.holderPos = 0;\n      }\n      this.updateActiveHolderPos();\n    },\n    goForward: function goForward() {\n      var _this2 = this;\n      this.autoPanBack();\n      // find the next element which rightPosition is bigger than holderPos,\n      // make this elements leftPos the new holderPos if the remaining space is bigger than containerWidth\n      // if remaining space is smaller\n      var newStartingItem;\n\n      // Array.find() not supported by Internet Explorer\n      this.tabItems.some(function (item) {\n        if (item.right > _this2.holderPos + _this2.containerWidth) {\n          newStartingItem = item;\n          return true;\n        }\n      });\n      if (!newStartingItem) {\n        return;\n      }\n      if (newStartingItem.remainingSpace >= this.containerWidth) {\n        this.holderPos = newStartingItem.left;\n      } else {\n        this.holderPos = this.holderWidth - this.containerWidth;\n      }\n      this.updateActiveHolderPos();\n    },\n    getPositions: function getPositions() {\n      var _this3 = this;\n      this.tabItems = [];\n      if (this.$refs.container) {\n        this.containerWidth = this.$refs.container.getBoundingClientRect().width;\n      }\n\n      // if pagination is needed but the pagination-arrows are not rendered yet\n      if (!this.$refs.arrow && this.paginationNeeded) {\n        this.containerWidth -= this.paginationWidth;\n      }\n      var itemLeft = 0;\n      this.$refs.tab.forEach(function (tab, ind) {\n        var itemWidth = tab.getBoundingClientRect().width;\n        var itemMarginLeft = parseInt(window.getComputedStyle(tab).getPropertyValue('margin-left'));\n        var itemMarginRight = parseInt(window.getComputedStyle(tab).getPropertyValue('margin-right'));\n        itemWidth += itemMarginLeft + itemMarginRight;\n        _this3.tabItems.push({\n          left: itemLeft,\n          width: itemWidth,\n          right: itemLeft + itemWidth,\n          title: _this3.tabs[ind].title,\n          remainingSpace: _this3.holderWidth - itemLeft\n        });\n        itemLeft += itemWidth;\n      });\n    },\n    findPosOfActiveTab: function findPosOfActiveTab() {\n      // go find in which portion the activeTab starts\n      // if it ends in the next portion add the difference in px\n\n      // check if activeTab is fully inside one portion\n      var numPortions = Math.ceil(this.holderWidth / this.containerWidth);\n      var leftOfActive = this.tabItems[this.tabIndex].left;\n      var rightOfActive = this.tabItems[this.tabIndex].right;\n      for (var i = 1; i <= numPortions; i++) {\n        if (leftOfActive < this.containerWidth * i) {\n          if (i < numPortions) {\n            this.holderPos = this.containerWidth * (i - 1);\n            // before last Portion, overlap possible\n            if (rightOfActive > this.containerWidth * i) {\n              // if active Element overlaps its portion, add the overlap to the holderPos\n              this.holderPos += rightOfActive - this.containerWidth * i;\n            }\n          }\n          if (i === numPortions) {\n            // last Portion, no overlap possible\n            // the last portion can be smaller than the containerWidth, so this assignment is safe:\n            this.holderPos = this.holderWidth - this.containerWidth;\n          }\n          break;\n        }\n      }\n      this.activeHolderPos = this.holderPos;\n    },\n    checkPagination: function checkPagination() {\n      this.paginationNeeded = false;\n      if (this.$refs.holder) {\n        this.holderWidth = this.$refs.holder.getBoundingClientRect().width;\n      }\n      if (this.$refs.tabnav.getBoundingClientRect().width < this.holderWidth) {\n        this.paginationNeeded = true;\n      }\n    },\n    showTabs: function showTabs() {\n      var _this4 = this;\n      window.requestAnimationFrame(function () {\n        window.requestAnimationFrame(function () {\n          _this4.noTransition = false;\n        });\n      });\n    },\n    redraw: function redraw() {\n      var _this5 = this;\n      // only redraw when resizing is complete, not on every single resize event\n      clearTimeout(this.timerId);\n      this.timerId = setTimeout(function () {\n        _this5.checkPagination();\n        if (_this5.paginationNeeded) {\n          _this5.getPositions();\n          _this5.findPosOfActiveTab();\n        } else {\n          // reset to beginning if no pagination needed\n          _this5.holderPos = 0;\n          _this5.getPositions();\n        }\n      }, 100);\n    }\n  },\n  created: function created() {\n    // needed for automatically panning back after inactivity after scrolling\n    this.activeHolderPos = undefined;\n    this.panTimerId = undefined;\n\n    // hardcoded, well..\n    this.paginationWidth = 40;\n    this.timerId = undefined;\n    window.addEventListener('resize', this.redraw);\n  },\n  mounted: function mounted() {\n    this.checkPagination();\n    this.getPositions();\n    this.findPosOfActiveTab();\n    this.showTabs();\n  },\n  beforeDestroy: function beforeDestroy() {\n    window.removeEventListener('resize', this.redraw);\n  }\n};",{"version":3,"sources":["TabNavigation.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4CA;AACA,OAAA,KAAA,cAAA;AAEA,eAAA;EACA,IAAA,EAAA,eAAA;EACA,KAAA,EAAA,CAAA,MAAA,EAAA,UAAA,EAAA,UAAA,CAAA;EACA,IAAA,WAAA,KAAA,EAAA;IACA,OAAA;MACA,gBAAA,EAAA,SAAA;MACA,YAAA,EAAA,IAAA;MACA,SAAA,EAAA,SAAA;MACA,cAAA,EAAA,SAAA;MACA,WAAA,EAAA,SAAA;MACA,eAAA,EAAA,SAAA;MACA,gBAAA,EAAA,cAAA,CAAA;IACA,CAAA;EACA,CAAA;EACA,OAAA,EAAA;IACA,SAAA,WAAA,UAAA,KAAA,EAAA;MACA,YAAA,CAAA,IAAA,CAAA,UAAA,CAAA;MAEA,IAAA,KAAA,GAAA,IAAA,CAAA,QAAA,EAAA;QACA,IAAA,CAAA,eAAA,GAAA,IAAA;MACA,CAAA,MAAA;QACA,IAAA,CAAA,eAAA,GAAA,KAAA;MACA;;MAEA;MACA,IAAA,IAAA,GAAA,IAAA,CAAA,QAAA,CAAA,KAAA,CAAA;;MAEA;MACA,IAAA,IAAA,CAAA,IAAA,GAAA,IAAA,CAAA,SAAA,EAAA;QACA,IAAA,KAAA,KAAA,CAAA,EAAA;UACA,IAAA,CAAA,SAAA,GAAA,CAAA;QACA,CAAA,MAAA;UACA,IAAA,CAAA,SAAA,GAAA,IAAA,CAAA,IAAA;QACA;MACA;MAEA,IAAA,IAAA,CAAA,KAAA,GAAA,IAAA,CAAA,SAAA,GAAA,IAAA,CAAA,cAAA,EAAA;QACA,IAAA,CAAA,SAAA,GAAA,IAAA,CAAA,KAAA,GAAA,IAAA,CAAA,cAAA;MACA;MAEA,IAAA,CAAA,eAAA,GAAA,IAAA,CAAA,SAAA;MACA,IAAA,CAAA,QAAA,CAAA,KAAA,CAAA;IAEA,CAAA;IACA,WAAA,WAAA,YAAA,EAAA;MAAA,IAAA,KAAA;MACA,YAAA,CAAA,IAAA,CAAA,UAAA,CAAA;MACA,IAAA,CAAA,UAAA,GAAA,UAAA,CAAA,YAAA;QACA,KAAA,CAAA,SAAA,GAAA,KAAA,CAAA,eAAA;MACA,CAAA,EAAA,IAAA,CAAA;IACA,CAAA;IACA,qBAAA,WAAA,sBAAA,EAAA;MACA;MACA,IAAA,QAAA,GAAA,IAAA,CAAA,QAAA,CAAA,IAAA,CAAA,QAAA,CAAA,CAAA,IAAA;MACA,IAAA,SAAA,GAAA,IAAA,CAAA,QAAA,CAAA,IAAA,CAAA,QAAA,CAAA,CAAA,KAAA;MACA,IAAA,UAAA,GAAA,IAAA,CAAA,SAAA;MACA,IAAA,WAAA,GAAA,IAAA,CAAA,SAAA,GAAA,IAAA,CAAA,cAAA;MACA,IACA,QAAA,GAAA,UAAA,IAAA,QAAA,GAAA,WAAA,IACA,SAAA,GAAA,UAAA,IAAA,SAAA,GAAA,WAAA,EACA;QACA,IAAA,CAAA,eAAA,GAAA,IAAA,CAAA,SAAA;MACA;IACA,CAAA;IACA,MAAA,WAAA,OAAA,EAAA;MACA,IAAA,CAAA,WAAA,CAAA,CAAA;MAEA,IAAA,eAAA;;MAEA;MACA,KAAA,IAAA,CAAA,GAAA,IAAA,CAAA,QAAA,CAAA,MAAA,GAAA,CAAA,EAAA,CAAA,IAAA,CAAA,EAAA,CAAA,EAAA,EAAA;QACA,IAAA,IAAA,CAAA,QAAA,CAAA,CAAA,CAAA,CAAA,IAAA,GAAA,IAAA,CAAA,SAAA,EAAA;UACA,eAAA,GAAA,IAAA,CAAA,QAAA,CAAA,CAAA,CAAA;UACA;QACA;MACA;MAEA,IAAA,CAAA,eAAA,EAAA;QACA;MACA;MAEA,IAAA,eAAA,CAAA,KAAA,IAAA,IAAA,CAAA,cAAA,EAAA;QACA,IAAA,CAAA,SAAA,GAAA,eAAA,CAAA,KAAA,GAAA,IAAA,CAAA,cAAA;MACA,CAAA,MAAA;QACA,IAAA,CAAA,SAAA,GAAA,CAAA;MACA;MAEA,IAAA,CAAA,qBAAA,CAAA,CAAA;IACA,CAAA;IACA,SAAA,WAAA,UAAA,EAAA;MAAA,IAAA,MAAA;MACA,IAAA,CAAA,WAAA,CAAA,CAAA;MACA;MACA;MACA;MACA,IAAA,eAAA;;MAEA;MACA,IAAA,CAAA,QAAA,CAAA,IAAA,CAAA,UAAA,IAAA,EAAA;QACA,IAAA,IAAA,CAAA,KAAA,GAAA,MAAA,CAAA,SAAA,GAAA,MAAA,CAAA,cAAA,EAAA;UACA,eAAA,GAAA,IAAA;UACA,OAAA,IAAA;QACA;MACA,CAAA,CAAA;MAEA,IAAA,CAAA,eAAA,EAAA;QACA;MACA;MAEA,IAAA,eAAA,CAAA,cAAA,IAAA,IAAA,CAAA,cAAA,EAAA;QACA,IAAA,CAAA,SAAA,GAAA,eAAA,CAAA,IAAA;MACA,CAAA,MAAA;QACA,IAAA,CAAA,SAAA,GAAA,IAAA,CAAA,WAAA,GAAA,IAAA,CAAA,cAAA;MACA;MAEA,IAAA,CAAA,qBAAA,CAAA,CAAA;IACA,CAAA;IACA,YAAA,WAAA,aAAA,EAAA;MAAA,IAAA,MAAA;MACA,IAAA,CAAA,QAAA,GAAA,EAAA;MAEA,IAAA,IAAA,CAAA,KAAA,CAAA,SAAA,EAAA;QACA,IAAA,CAAA,cAAA,GAAA,IAAA,CAAA,KAAA,CAAA,SAAA,CAAA,qBAAA,CAAA,CAAA,CAAA,KAAA;MACA;;MAEA;MACA,IAAA,CAAA,IAAA,CAAA,KAAA,CAAA,KAAA,IAAA,IAAA,CAAA,gBAAA,EAAA;QACA,IAAA,CAAA,cAAA,IAAA,IAAA,CAAA,eAAA;MACA;MAEA,IAAA,QAAA,GAAA,CAAA;MACA,IAAA,CAAA,KAAA,CAAA,GAAA,CAAA,OAAA,CAAA,UAAA,GAAA,EAAA,GAAA,EAAA;QACA,IAAA,SAAA,GAAA,GAAA,CAAA,qBAAA,CAAA,CAAA,CAAA,KAAA;QACA,IAAA,cAAA,GAAA,QAAA,CAAA,MAAA,CAAA,gBAAA,CAAA,GAAA,CAAA,CAAA,gBAAA,CAAA,aAAA,CAAA,CAAA;QACA,IAAA,eAAA,GAAA,QAAA,CAAA,MAAA,CAAA,gBAAA,CAAA,GAAA,CAAA,CAAA,gBAAA,CAAA,cAAA,CAAA,CAAA;QAEA,SAAA,IAAA,cAAA,GAAA,eAAA;QAEA,MAAA,CAAA,QAAA,CAAA,IAAA,CAAA;UACA,IAAA,EAAA,QAAA;UACA,KAAA,EAAA,SAAA;UACA,KAAA,EAAA,QAAA,GAAA,SAAA;UACA,KAAA,EAAA,MAAA,CAAA,IAAA,CAAA,GAAA,CAAA,CAAA,KAAA;UACA,cAAA,EAAA,MAAA,CAAA,WAAA,GAAA;QACA,CAAA,CAAA;QACA,QAAA,IAAA,SAAA;MACA,CAAA,CAAA;IACA,CAAA;IACA,kBAAA,WAAA,mBAAA,EAAA;MAEA;MACA;;MAEA;MACA,IAAA,WAAA,GAAA,IAAA,CAAA,IAAA,CAAA,IAAA,CAAA,WAAA,GAAA,IAAA,CAAA,cAAA,CAAA;MACA,IAAA,YAAA,GAAA,IAAA,CAAA,QAAA,CAAA,IAAA,CAAA,QAAA,CAAA,CAAA,IAAA;MACA,IAAA,aAAA,GAAA,IAAA,CAAA,QAAA,CAAA,IAAA,CAAA,QAAA,CAAA,CAAA,KAAA;MAEA,KAAA,IAAA,CAAA,GAAA,CAAA,EAAA,CAAA,IAAA,WAAA,EAAA,CAAA,EAAA,EAAA;QACA,IAAA,YAAA,GAAA,IAAA,CAAA,cAAA,GAAA,CAAA,EAAA;UACA,IAAA,CAAA,GAAA,WAAA,EAAA;YACA,IAAA,CAAA,SAAA,GAAA,IAAA,CAAA,cAAA,IAAA,CAAA,GAAA,CAAA,CAAA;YACA;YACA,IAAA,aAAA,GAAA,IAAA,CAAA,cAAA,GAAA,CAAA,EAAA;cACA;cACA,IAAA,CAAA,SAAA,IAAA,aAAA,GAAA,IAAA,CAAA,cAAA,GAAA,CAAA;YACA;UACA;UACA,IAAA,CAAA,KAAA,WAAA,EAAA;YACA;YACA;YACA,IAAA,CAAA,SAAA,GAAA,IAAA,CAAA,WAAA,GAAA,IAAA,CAAA,cAAA;UACA;UAEA;QACA;MACA;MAEA,IAAA,CAAA,eAAA,GAAA,IAAA,CAAA,SAAA;IAEA,CAAA;IACA,eAAA,WAAA,gBAAA,EAAA;MACA,IAAA,CAAA,gBAAA,GAAA,KAAA;MACA,IAAA,IAAA,CAAA,KAAA,CAAA,MAAA,EAAA;QACA,IAAA,CAAA,WAAA,GAAA,IAAA,CAAA,KAAA,CAAA,MAAA,CAAA,qBAAA,CAAA,CAAA,CAAA,KAAA;MACA;MACA,IAAA,IAAA,CAAA,KAAA,CAAA,MAAA,CAAA,qBAAA,CAAA,CAAA,CAAA,KAAA,GAAA,IAAA,CAAA,WAAA,EAAA;QACA,IAAA,CAAA,gBAAA,GAAA,IAAA;MACA;IACA,CAAA;IACA,QAAA,WAAA,SAAA,EAAA;MAAA,IAAA,MAAA;MACA,MAAA,CAAA,qBAAA,CAAA,YAAA;QACA,MAAA,CAAA,qBAAA,CAAA,YAAA;UACA,MAAA,CAAA,YAAA,GAAA,KAAA;QACA,CAAA,CAAA;MACA,CAAA,CAAA;IACA,CAAA;IACA,MAAA,WAAA,OAAA,EAAA;MAAA,IAAA,MAAA;MACA;MACA,YAAA,CAAA,IAAA,CAAA,OAAA,CAAA;MACA,IAAA,CAAA,OAAA,GAAA,UAAA,CAAA,YAAA;QACA,MAAA,CAAA,eAAA,CAAA,CAAA;QACA,IAAA,MAAA,CAAA,gBAAA,EAAA;UACA,MAAA,CAAA,YAAA,CAAA,CAAA;UACA,MAAA,CAAA,kBAAA,CAAA,CAAA;QACA,CAAA,MAAA;UACA;UACA,MAAA,CAAA,SAAA,GAAA,CAAA;UACA,MAAA,CAAA,YAAA,CAAA,CAAA;QACA;MACA,CAAA,EAAA,GAAA,CAAA;IACA;EACA,CAAA;EACA,OAAA,WAAA,QAAA,EAAA;IACA;IACA,IAAA,CAAA,eAAA,GAAA,SAAA;IAEA,IAAA,CAAA,UAAA,GAAA,SAAA;;IAEA;IACA,IAAA,CAAA,eAAA,GAAA,EAAA;IAEA,IAAA,CAAA,OAAA,GAAA,SAAA;IACA,MAAA,CAAA,gBAAA,CAAA,QAAA,EAAA,IAAA,CAAA,MAAA,CAAA;EACA,CAAA;EACA,OAAA,WAAA,QAAA,EAAA;IACA,IAAA,CAAA,eAAA,CAAA,CAAA;IACA,IAAA,CAAA,YAAA,CAAA,CAAA;IACA,IAAA,CAAA,kBAAA,CAAA,CAAA;IACA,IAAA,CAAA,QAAA,CAAA,CAAA;EACA,CAAA;EACA,aAAA,WAAA,cAAA,EAAA;IACA,MAAA,CAAA,mBAAA,CAAA,QAAA,EAAA,IAAA,CAAA,MAAA,CAAA;EACA;AACA,CAAA","sourcesContent":["<template>\n  <div class=\"tab-nav\" ref=\"tabnav\">\n\n    <div v-if=\"paginationNeeded\" ref=\"arrow\">\n      <div class=\"tab-nav-arrow tn-left\"\n        :class=\"{'tn-active': holderPos!==0}\" v-on:click=\"goBack\"\n      >\n        <img src=\"/img/arrow-left.svg\">\n      </div>\n      <div class=\"tab-nav-arrow tn-right\"\n        v-if=\"paginationNeeded\"\n        :class=\"{'tn-active': holderPos < holderWidth-containerWidth}\" v-on:click=\"goForward\"\n      >\n        <img src=\"/img/arrow-right.svg\">\n      </div>\n    </div>\n\n    <div class=\"tab-nav-cont\" ref=\"container\" :class=\"{'tn-paginated': paginationNeeded}\">\n\n      <div class=\"tab-nav-holder\" ref=\"holder\"\n        :class=\"{'tn-inactive': noTransition}\"\n        :style=\"{transform: 'translateX(-'+holderPos+'px)'}\"\n      >\n        <span v-for=\"(tab,index) in tabs\" ref=\"tab\" :key=\"tab.title\" class=\"tab-item\"\n          :class=\"{\n            selected:tabIndex===index,\n            'tn-left': tabIndex===index && isLeftDirection,\n            'tn-right': tabIndex===index && !isLeftDirection,\n          }\"\n          v-on:click=\"selectTab(index)\"\n        >\n          <div class=\"tab-item-title\">\n            <span>{{tab.title}}</span>\n            <span v-if=\"tabsWithWarnings.indexOf(tab.route) >= 0\" class=\"tab-item-warning\">!</span>\n          </div>\n        </span>\n      </div>\n\n    </div>\n\n  </div>\n</template>\n\n<script>\n// needs the outputsService for the tabsWithWarnings\nimport * as outputsService from '../outputsService.js';\n\nexport default {\n  name: 'TabNavigation',\n  props: ['tabs', 'tabIndex', 'callback'],\n  data() {\n    return {\n      paginationNeeded: undefined,\n      noTransition: true,\n      holderPos: undefined,\n      containerWidth: undefined,\n      holderWidth: undefined,\n      isLeftDirection: undefined,\n      tabsWithWarnings: outputsService.tabsWithWarnings\n    }\n  },\n  methods: {\n    selectTab(index) {\n      clearTimeout(this.panTimerId);\n\n      if(index < this.tabIndex) {\n        this.isLeftDirection = true;\n      } else {\n        this.isLeftDirection = false;\n      }\n\n      // check wether item is fully visible, if not make it fully visible\n      let item = this.tabItems[index];\n\n      // item was clicked, so no need to check weather it is inside the visible portion\n      if(item.left < this.holderPos) {\n        if(index === 0) {\n          this.holderPos = 0;\n        } else {\n          this.holderPos = item.left\n        }\n      }\n\n      if(item.right > this.holderPos + this.containerWidth) {\n        this.holderPos = item.right - this.containerWidth;\n      }\n\n      this.activeHolderPos = this.holderPos;\n      this.callback(index);\n\n    },\n    autoPanBack() {\n      clearTimeout(this.panTimerId);\n      this.panTimerId = setTimeout(() => {\n        this.holderPos = this.activeHolderPos;\n      }, 4000);\n    },\n    updateActiveHolderPos() {\n      // check if active item is still visible\n      let itemLeft = this.tabItems[this.tabIndex].left;\n      let itemRight = this.tabItems[this.tabIndex].right;\n      let holderLeft = this.holderPos;\n      let holderRight = this.holderPos + this.containerWidth;\n      if(\n          (itemLeft > holderLeft && itemLeft < holderRight) ||\n          (itemRight > holderLeft && itemRight < holderRight)\n        ) {\n            this.activeHolderPos = this.holderPos;\n      }\n    },\n    goBack() {\n      this.autoPanBack();\n\n      let newStartingItem;\n\n      // find first item, that starts on the left side of current portion\n      for(let i=this.tabItems.length-1; i >= 0; i--) {\n        if(this.tabItems[i].left < this.holderPos) {\n          newStartingItem = this.tabItems[i];\n          break;\n        }\n      }\n\n      if(!newStartingItem) {\n        return;\n      }\n\n      if(newStartingItem.right >= this.containerWidth) {\n        this.holderPos = newStartingItem.right-this.containerWidth;\n      } else {\n        this.holderPos = 0;\n      }\n\n      this.updateActiveHolderPos();\n    },\n    goForward() {\n      this.autoPanBack();\n      // find the next element which rightPosition is bigger than holderPos,\n      // make this elements leftPos the new holderPos if the remaining space is bigger than containerWidth\n      // if remaining space is smaller\n      let newStartingItem;\n\n      // Array.find() not supported by Internet Explorer\n      this.tabItems.some((item) => {\n         if(item.right > this.holderPos + this.containerWidth) {\n           newStartingItem = item;\n           return true;\n         }\n      });\n\n      if(!newStartingItem) {\n        return;\n      }\n\n      if(newStartingItem.remainingSpace >= this.containerWidth) {\n        this.holderPos = newStartingItem.left;\n      } else {\n        this.holderPos = this.holderWidth - this.containerWidth;\n      }\n\n      this.updateActiveHolderPos();\n    },\n    getPositions() {\n      this.tabItems = [];\n\n      if(this.$refs.container) {\n        this.containerWidth = this.$refs.container.getBoundingClientRect().width;\n      }\n\n      // if pagination is needed but the pagination-arrows are not rendered yet\n      if(!this.$refs.arrow && this.paginationNeeded) {\n        this.containerWidth -= this.paginationWidth;\n      }\n\n      let itemLeft = 0;\n      this.$refs.tab.forEach((tab, ind) => {\n        let itemWidth = tab.getBoundingClientRect().width;\n        let itemMarginLeft = parseInt(window.getComputedStyle(tab).getPropertyValue('margin-left'));\n        let itemMarginRight = parseInt(window.getComputedStyle(tab).getPropertyValue('margin-right'));\n\n        itemWidth += itemMarginLeft + itemMarginRight;\n\n        this.tabItems.push({\n          left: itemLeft,\n          width: itemWidth,\n          right: itemLeft + itemWidth,\n          title: this.tabs[ind].title,\n          remainingSpace: this.holderWidth - itemLeft\n        });\n        itemLeft += itemWidth;\n      });\n    },\n    findPosOfActiveTab() {\n\n      // go find in which portion the activeTab starts\n      // if it ends in the next portion add the difference in px\n\n      // check if activeTab is fully inside one portion\n      let numPortions = Math.ceil(this.holderWidth / this.containerWidth);\n      let leftOfActive = this.tabItems[this.tabIndex].left;\n      let rightOfActive = this.tabItems[this.tabIndex].right;\n\n      for(let i=1; i<=numPortions; i++) {\n        if(leftOfActive < this.containerWidth*i) {\n          if(i<numPortions) {\n            this.holderPos = this.containerWidth*(i-1);\n            // before last Portion, overlap possible\n            if(rightOfActive > this.containerWidth*i) {\n              // if active Element overlaps its portion, add the overlap to the holderPos\n              this.holderPos += rightOfActive - this.containerWidth*i;\n            }\n          }\n          if(i === numPortions) {\n            // last Portion, no overlap possible\n            // the last portion can be smaller than the containerWidth, so this assignment is safe:\n            this.holderPos = this.holderWidth - this.containerWidth;\n          }\n\n          break;\n        }\n      }\n\n      this.activeHolderPos = this.holderPos;\n\n    },\n    checkPagination() {\n      this.paginationNeeded = false;\n      if(this.$refs.holder) {\n        this.holderWidth = this.$refs.holder.getBoundingClientRect().width;\n      }\n      if(this.$refs.tabnav.getBoundingClientRect().width < this.holderWidth) {\n        this.paginationNeeded = true;\n      }\n    },\n    showTabs() {\n      window.requestAnimationFrame(() => {\n        window.requestAnimationFrame(() => {\n          this.noTransition = false;\n        });\n      });\n    },\n    redraw() {\n      // only redraw when resizing is complete, not on every single resize event\n      clearTimeout(this.timerId);\n      this.timerId = setTimeout(() => {\n        this.checkPagination();\n        if(this.paginationNeeded) {\n          this.getPositions();\n          this.findPosOfActiveTab();\n        } else {\n          // reset to beginning if no pagination needed\n          this.holderPos = 0;\n          this.getPositions();\n        }\n      }, 100);\n    }\n  },\n  created() {\n    // needed for automatically panning back after inactivity after scrolling\n    this.activeHolderPos = undefined;\n\n    this.panTimerId = undefined;\n\n    // hardcoded, well..\n    this.paginationWidth = 40;\n\n    this.timerId = undefined;\n    window.addEventListener('resize', this.redraw);\n  },\n  mounted() {\n    this.checkPagination();\n    this.getPositions();\n    this.findPosOfActiveTab();\n    this.showTabs();\n  },\n  beforeDestroy() {\n    window.removeEventListener('resize', this.redraw);\n  }\n}\n</script>\n\n<style>\n.tab-nav {\n  width: 100%;\n  /*height needs to be set by containing element (outer container that holds this component)*/\n  height: 100%;\n  position: relative;\n  background-color: white;\n  overflow: hidden;\n}\n.tab-nav-arrow {\n  height: 100%;\n  width: 20px;\n  position: absolute;\n  top: 0px;\n  z-index: 10;\n}\n.tab-nav-arrow::after {\n  content: '';\n  position: absolute;\n  bottom: 0px;\n  left: 0px;\n  width: 100%;\n  height: 5px;\n  background-color: white;\n}\n.tab-nav-arrow.tn-left {\n  left: 0px;\n  background: linear-gradient(to right, rgba(255, 255, 255, 1) 0%, rgba(255, 255, 255, 1) 80%, rgba(255, 255, 255, 0) 100%);\n}\n.tab-nav-arrow.tn-right {\n  right: 0px;\n  background: linear-gradient(to right, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 1) 20%, rgba(255, 255, 255, 1) 100%);\n}\n.tab-nav-arrow img {\n  position: absolute;\n  height: 16px;\n  display: block;\n  top: 40%;\n  transform: translateY(-50%);\n  opacity: 0;\n  transition: opacity 0.3s ease;\n}\n.tab-nav-arrow.tn-right img {\n  right: 0px;\n}\n.tab-nav-arrow.tn-left img {\n  left: 0px;\n}\n.tab-nav-arrow.tn-active img {\n  opacity: 1;\n  cursor: pointer;\n}\n\n.tab-nav-cont {\n  /*can't use flex with flex-grow, because on page-load .tab-nav-cont doesn't take up full width,\n  only after 150ms it would. Use as normal block-div works,\n  but then the arrows need to use position absolute */\n  height: 100%;\n  margin: 0px;\n  position: relative;\n\n}\n.tab-nav-cont.tn-paginated {\n  margin: 0px 20px;\n}\n.tn-mask {\n  flex: none;\n  width: 10px;\n  align-self: stretch;\n  z-index: 2;\n  pointer-events: none;\n}\n.tn-mask-left {\n  background: linear-gradient(to right, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0));\n}\n.tn-mask-right {\n  background: linear-gradient(to right, rgba(255, 255, 255, 0), rgba(255, 255, 255, 1));\n}\n\n.tab-nav-holder {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  height: 100%;\n  display: flex;\n  align-items: center;\n  transition: transform 1s cubic-bezier(0.35, 0, 0.25, 1);\n}\n.tab-nav-holder.tn-inactive {\n  transition-duration: 0s;\n}\n\n</style>\n"],"sourceRoot":"src/lib"}]}