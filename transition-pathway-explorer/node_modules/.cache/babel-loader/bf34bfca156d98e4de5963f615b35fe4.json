{"remainingRequest":"/Users/paruta/2050-Calculators/PathwayCalc/transition-pathway-explorer/node_modules/babel-loader/lib/index.js!/Users/paruta/2050-Calculators/PathwayCalc/transition-pathway-explorer/node_modules/eslint-loader/index.js??ref--13-0!/Users/paruta/2050-Calculators/PathwayCalc/transition-pathway-explorer/src/chartSeriesBuilders.js","dependencies":[{"path":"/Users/paruta/2050-Calculators/PathwayCalc/transition-pathway-explorer/src/chartSeriesBuilders.js","mtime":1707210098267},{"path":"/Users/paruta/2050-Calculators/PathwayCalc/transition-pathway-explorer/node_modules/cache-loader/dist/cjs.js","mtime":1707234519865},{"path":"/Users/paruta/2050-Calculators/PathwayCalc/transition-pathway-explorer/node_modules/babel-loader/lib/index.js","mtime":1707234519797},{"path":"/Users/paruta/2050-Calculators/PathwayCalc/transition-pathway-explorer/node_modules/eslint-loader/index.js","mtime":1707234519720}],"contextDependencies":[],"result":["import \"core-js/modules/es7.object.get-own-property-descriptors\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es6.function.name\";\nimport _defineProperty from \"/Users/paruta/2050-Calculators/PathwayCalc/transition-pathway-explorer/node_modules/@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport \"core-js/modules/es6.math.sign\";\nimport \"core-js/modules/es6.array.sort\";\nimport \"core-js/modules/es6.array.find\";\nimport _slicedToArray from \"/Users/paruta/2050-Calculators/PathwayCalc/transition-pathway-explorer/node_modules/@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport \"core-js/modules/web.dom.iterable\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n// TODO:\n// restructure this module for more readability\n// findNullstellen should only accept a single series and only require the series with x and y values as a single parameter\n\nexport function buildChartData(countryCode, chartDef, outputs, withNegative) {\n  var timeAxis;\n  var series = [];\n  var totalData = [];\n\n  // chartDef.outputs only contains the keys (strings) used in outputs\n  chartDef.outputs.forEach(function (outp) {\n    // skip custom outputs\n    if (outp.custom) {\n      return;\n    }\n\n    // outputs[outp] might exist (created from frontend config file),\n    // but outputs[outp].data or outputs[outp].timeAxis might not exist (if this output is unknown to the API)\n    // if an output is unknown to API and it wasn't listed in the Outputs config constant, then outputs[outp] is undefined\n    // outputs that are not listed in the Outputs config constant only get initialized into outputs on a succesful API fetch\n    if (!outputs[outp.id] || !outputs[outp.id].data) {\n      return;\n    }\n    if (!timeAxis) {\n      // outp.timeAxis can still be undefined (if output is unknown to API),\n      // but then it is looked for one on the next iteration\n      timeAxis = outputs[outp.id].timeAxis;\n    }\n    if (timeAxis) {\n      var data = outputs[outp.id].data[countryCode];\n      if (data.length) {\n        data = data.map(function (value, index) {\n          // side-effect: also sum up the total-data\n          if (withNegative) {\n            if (!totalData[index]) {\n              totalData[index] = {\n                x: timeAxis[index],\n                y: 0\n              };\n            }\n            totalData[index].y += value;\n          }\n\n          // modify the data format from [xValue,yValue] to {x:xValue, y:yValue}\n          return {\n            x: timeAxis[index],\n            y: chartDef.modifier ? chartDef.modifier(value) : value\n          };\n        });\n        if (data.length === timeAxis.length) {\n          series.push({\n            name: outp.title ? outp.title : outputs[outp.id].title,\n            id: outp.id,\n            //necessary for chart update\n            color: outp.color ? outp.color : undefined,\n            data: data\n          });\n        }\n      }\n    }\n  });\n\n  // if API data is not available yet, this case is caught outisde of this function already\n  // but this check is still kept for security reasons\n  if (!timeAxis) {\n    return;\n  }\n  if (withNegative) {\n    series = formatSeriesWithNullstellen(timeAxis, series);\n    var totalSeries = {\n      type: 'line',\n      name: chartDef.totalTitle ? chartDef.totalTitle : 'total',\n      id: 'total',\n      color: '#f44141',\n      data: totalData\n    };\n    series.push(totalSeries);\n  }\n  return {\n    series: series,\n    title: chartDef.title,\n    unit: chartDef.unit,\n    timeAxis: timeAxis.slice() // ditch observer\n  };\n}\nfunction formatSeriesWithNullstellen(timeAxis, series) {\n  // timeAxis: [..,2012,2013,2014,..]\n  // series: [{name: \"\", id: \"\", color: \"\", data: [{x:1,y:2}, {x:2,y:3}, ..]}, ..]\n  // all series-data should be sanitized/filtered already!\n  // timeAxis.length must match all data.length\n  var _findNullstellen = findNullstellen(timeAxis, series),\n    _findNullstellen2 = _slicedToArray(_findNullstellen, 2),\n    nullstellen = _findNullstellen2[0],\n    nullStellenBySeriesId = _findNullstellen2[1]; // nullstellen does not contain any values which are already part of the timeAxis\n  // calculate intermediate values for all series (necessary, otherwise gaps appear in areas where no data is defined)\n  nullstellen.forEach(function (nullst) {\n    series.forEach(function (ser) {\n      var seriesContainsEntry = ser.data.some(function (point) {\n        return point.x === nullst.x;\n      });\n      if (!seriesContainsEntry) {\n        var y;\n        if (nullStellenBySeriesId[ser.id] && nullStellenBySeriesId[ser.id].indexOf(nullst.x) >= 0) {\n          y = 0;\n        } else {\n          //linear interpolation\n          var pointBefore = ser.data.find(function (point) {\n            return point.x === nullst.xBefore;\n          });\n          var pointAfter = ser.data.find(function (point) {\n            return point.x === nullst.xAfter;\n          });\n          y = linearInterpolatePoint(nullst.x, nullst.xBefore, nullst.xAfter, pointBefore.y, pointAfter.y);\n        }\n        if (typeof y !== \"undefined\") {\n          ser.data.push({\n            x: nullst.x,\n            y: y,\n            // states: {hover: {enabled: false}},\n            // marker: {enabled: false},\n            marker: {\n              states: {\n                hover: {\n                  enabled: false\n                }\n              }\n            },\n            noTooltip: true\n          });\n        }\n      }\n    });\n  });\n\n  // sort all data arrays of all series (Highcharts need data to be sorted by x)\n  series.forEach(function (ser) {\n    ser.data.sort(function compare(a, b) {\n      if (a.x < b.x) {\n        return -1;\n      }\n      if (a.x > b.x) {\n        return 1;\n      }\n      // a must be equal to b\n      return 0;\n    });\n  });\n\n  // split seriesData according to positive or negative stack\n  // important! The series.data need to be sorted already!\n  var _splitSeriesData = splitSeriesData(series),\n    _splitSeriesData2 = _slicedToArray(_splitSeriesData, 2),\n    positiveSeries = _splitSeriesData2[0],\n    negativeSeries = _splitSeriesData2[1];\n  series = positiveSeries.concat(negativeSeries);\n  return series;\n}\nexport function findNullstellen(timeAxis, seriesData) {\n  var xTolerance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.001;\n  // timeAxis: [..,2012,2013,2014,..]\n  // seriesData: [{id: \"\", data: [{y:2}, {y:3}, ..]}, ..]\n  // returns all Nullstellen of all series in seriesData merged into one object (intermediateTimes)\n  // ignores nullstellen that already land on a timeAxis-Stelle\n\n  var intermediateTimes = []; // [{x: 2012.4, xBefore: 2012, xAfter: 2013}]\n\n  var nullStellenBySeriesId = {}; // {\"someId\": [2012.4, 2015.6], ..}\n\n  seriesData.forEach(function (ser) {\n    var activePart = \"positive\";\n    var valueBefore;\n    for (var i = 0, len = timeAxis.length; i < len; i++) {\n      var x = timeAxis[i];\n      var value = ser.data[i].y;\n      var crossingFound = void 0;\n\n      // switch activePart on sign change\n      // zero values are ignored, because they are already part of the series\n      // and duplicate datapoints would lead to bugs in rendering\n      if (value < 0) {\n        if (activePart === \"positive\" && i > 0 && i < len) {\n          crossingFound = true;\n        }\n        activePart = \"negative\";\n      }\n      if (value > 0) {\n        if (activePart === \"negative\" && i > 0 && i < len) {\n          crossingFound = true;\n        }\n        activePart = \"positive\";\n      }\n      if (crossingFound) {\n        var xBefore = timeAxis[i - 1];\n        var m = (value - valueBefore) / (x - xBefore); // x and xBefore are sometimes more than one unit apart!!\n        var x0 = -1 * valueBefore / m + xBefore; //y1/m + x1\n\n        // don't add Nullstellen that already exist in the timeAxis, because duplicate datapoints lead to rendering errors\n        // also don't add datapoints if the nullStelle is already within tolerance to an already existing datapoint\n        if (timeAxis.indexOf(x0) >= 0 || x0 - xBefore < xTolerance || x - x0 < xTolerance) {\n          continue;\n        }\n\n        // setting toFixed() to 6 is important, if setting toFixed(2) sometimes it hits a round year\n        // which results in double entries in data, because parseFloat is ignoring zero decimals.\n        // parseFloat(2009.00) =>> 2009\n        // also if there are two equal nullstellen which might happen with toFixed(2)\n        // it also results in the error, that the highcharts updates are jumpy\n        // I haven't been able to fully track down the error, but using .toFixed(6)\n        // mitigates it and makes it much less likely to occur\n\n        intermediateTimes.push({\n          // x: nullStelle,\n          x: x0,\n          xBefore: xBefore,\n          xAfter: x\n        });\n        if (nullStellenBySeriesId[ser.id]) {\n          nullStellenBySeriesId[ser.id].push(x0);\n        } else {\n          nullStellenBySeriesId[ser.id] = [x0];\n        }\n      }\n      valueBefore = value;\n    }\n  });\n  return [intermediateTimes, nullStellenBySeriesId];\n}\nfunction linearInterpolatePoint(x, xBefore, xAfter, yBefore, yAfter) {\n  var y;\n  if (typeof xBefore !== 'undefined' && typeof xAfter !== 'undefined' && typeof yBefore !== 'undefined' && typeof yAfter !== 'undefined') {\n    var m = (yAfter - yBefore) / (xAfter - xBefore);\n    y = m * (x - xBefore) + yBefore;\n  }\n  // y can be undefined\n  return y;\n}\nfunction splitSeriesData(seriesData) {\n  // all series.data needs to be sorted already\n\n  // [{x:2015, y: 10},{x: 2015.5, y: 0},{x: 2016, y: 0},{x: 2017},{},{},{},{}]\n  //\n  // only y:0 are relevant\n  // when 0 is hit it gets written in the currentactivePart\n  // when a sign change happens to negative, the negative value gets written in the negativePart,\n  // but also the negativePart needs the 0 in it entered for the xBefore\n  //\n  // It always hits the 0, it never jumps directly to negative values!\n  // If it hits the 0 and the next value has a different sign, then the 0 gets written in both parts.\n\n  var positiveSeries = [];\n  var negativeSeries = [];\n  seriesData.forEach(function (series) {\n    var data = series.data;\n    var positiveData = [];\n    var negativeData = [];\n    var activePart = positiveData;\n    for (var i = 0, len = data.length; i < len; i++) {\n      var point = data[i];\n      var y = data[i].y;\n      if (y > 0) {\n        positiveData.push(point);\n        activePart = positiveData;\n      }\n      if (y < 0) {\n        negativeData.push(point);\n        activePart = negativeData;\n      }\n      if (y === 0) {\n        //ignore when first or last entry\n        if (i > 0 && i < len - 1) {\n          var yBefore = data[i - 1].y;\n          var yAfter = data[i + 1].y;\n          if (Math.sign(yBefore) !== Math.sign(yAfter)) {\n            // push to both parts, when 0 is followed by a sign change\n            // but disable the tooltip for one\n            positiveData.push(point);\n            negativeData.push(_objectSpread({}, point, {\n              //spread operator\n              noTooltip: true\n            }));\n          } else {\n            // if no sign change, just push to current active part\n            activePart.push(point);\n          }\n        } else {\n          // if 0 is first or last value it gets pushed to the current active part.\n          // activePart is positiveData for i==0\n          activePart.push(point);\n        }\n      }\n    }\n    positiveSeries.push({\n      name: series.name,\n      type: 'area',\n      id: series.id ? series.id : series.name,\n      data: positiveData,\n      stack: 'positive',\n      color: series.color ? series.color : undefined\n    });\n    negativeSeries.push({\n      name: series.name,\n      type: 'area',\n      linkedTo: series.id,\n      id: series.id ? series.id + 'neg' : series.name + 'neg',\n      //id also necessary for negative series (for animated data update) I guess\n      data: negativeData,\n      stack: 'negative',\n      color: series.color ? series.color : undefined\n    });\n  });\n  return [positiveSeries, negativeSeries];\n}",{"version":3,"names":["buildChartData","countryCode","chartDef","outputs","withNegative","timeAxis","series","totalData","forEach","outp","custom","id","data","length","map","value","index","x","y","modifier","push","name","title","color","undefined","formatSeriesWithNullstellen","totalSeries","type","totalTitle","unit","slice","_findNullstellen","findNullstellen","_findNullstellen2","_slicedToArray","nullstellen","nullStellenBySeriesId","nullst","ser","seriesContainsEntry","some","point","indexOf","pointBefore","find","xBefore","pointAfter","xAfter","linearInterpolatePoint","marker","states","hover","enabled","noTooltip","sort","compare","a","b","_splitSeriesData","splitSeriesData","_splitSeriesData2","positiveSeries","negativeSeries","concat","seriesData","xTolerance","arguments","intermediateTimes","activePart","valueBefore","i","len","crossingFound","m","x0","yBefore","yAfter","positiveData","negativeData","Math","sign","_objectSpread","stack","linkedTo"],"sources":["/Users/paruta/2050-Calculators/PathwayCalc/transition-pathway-explorer/src/chartSeriesBuilders.js"],"sourcesContent":["// TODO:\n// restructure this module for more readability\n// findNullstellen should only accept a single series and only require the series with x and y values as a single parameter\n\nexport function buildChartData(countryCode, chartDef, outputs, withNegative) {\n  var timeAxis;\n  var series = [];\n  var totalData = [];\n\n  // chartDef.outputs only contains the keys (strings) used in outputs\n  chartDef.outputs.forEach((outp) => {\n\n    // skip custom outputs\n    if(outp.custom) {\n      return;\n    }\n\n    // outputs[outp] might exist (created from frontend config file),\n    // but outputs[outp].data or outputs[outp].timeAxis might not exist (if this output is unknown to the API)\n    // if an output is unknown to API and it wasn't listed in the Outputs config constant, then outputs[outp] is undefined\n    // outputs that are not listed in the Outputs config constant only get initialized into outputs on a succesful API fetch\n    if(!outputs[outp.id] || !outputs[outp.id].data) {\n      return;\n    }\n    if(!timeAxis) {\n      // outp.timeAxis can still be undefined (if output is unknown to API),\n      // but then it is looked for one on the next iteration\n      timeAxis = outputs[outp.id].timeAxis;\n    }\n\n    if(timeAxis) {\n      let data = outputs[outp.id].data[countryCode];\n\n      if(data.length) {\n        data = data.map((value, index) => {\n\n          // side-effect: also sum up the total-data\n          if(withNegative) {\n            if(!totalData[index]) {\n              totalData[index] = {\n                x: timeAxis[index],\n                y: 0\n              };\n            }\n            totalData[index].y += value;\n          }\n\n          // modify the data format from [xValue,yValue] to {x:xValue, y:yValue}\n          return {\n            x: timeAxis[index],\n            y: chartDef.modifier ? chartDef.modifier(value) : value\n          };\n        });\n\n        if(data.length === timeAxis.length) {\n          series.push({\n            name: outp.title ? outp.title : outputs[outp.id].title,\n            id: outp.id, //necessary for chart update\n            color: outp.color ? outp.color : undefined,\n            data: data\n          });\n        }\n      }\n    }\n  });\n\n  // if API data is not available yet, this case is caught outisde of this function already\n  // but this check is still kept for security reasons\n  if(!timeAxis) {\n    return;\n  }\n\n  if(withNegative) {\n    series = formatSeriesWithNullstellen(timeAxis, series);\n\n    let totalSeries = {\n      type: 'line',\n      name: chartDef.totalTitle ? chartDef.totalTitle : 'total',\n      id: 'total',\n      color: '#f44141',\n      data: totalData\n    };\n    series.push(totalSeries);\n  }\n\n  return {\n    series: series,\n    title: chartDef.title,\n    unit: chartDef.unit,\n    timeAxis: timeAxis.slice() // ditch observer\n  }\n}\n\nfunction formatSeriesWithNullstellen(timeAxis, series) {\n  // timeAxis: [..,2012,2013,2014,..]\n  // series: [{name: \"\", id: \"\", color: \"\", data: [{x:1,y:2}, {x:2,y:3}, ..]}, ..]\n  // all series-data should be sanitized/filtered already!\n  // timeAxis.length must match all data.length\n\n  let [nullstellen, nullStellenBySeriesId] = findNullstellen(timeAxis, series);\n  // nullstellen does not contain any values which are already part of the timeAxis\n\n  // calculate intermediate values for all series (necessary, otherwise gaps appear in areas where no data is defined)\n  nullstellen.forEach((nullst) => {\n\n    series.forEach((ser) => {\n      let seriesContainsEntry = ser.data.some((point) => {\n        return point.x === nullst.x;\n      });\n      if(!seriesContainsEntry) {\n        let y;\n\n        if(nullStellenBySeriesId[ser.id] && nullStellenBySeriesId[ser.id].indexOf(nullst.x) >= 0) {\n          y = 0;\n        } else {\n          //linear interpolation\n          let pointBefore = ser.data.find((point) => point.x === nullst.xBefore);\n          let pointAfter = ser.data.find((point) => point.x === nullst.xAfter);\n          y = linearInterpolatePoint(nullst.x, nullst.xBefore, nullst.xAfter, pointBefore.y, pointAfter.y);\n        }\n\n        if(typeof y !== \"undefined\") {\n          ser.data.push({\n            x: nullst.x,\n            y: y,\n            // states: {hover: {enabled: false}},\n            // marker: {enabled: false},\n            marker: {\n              states: {\n                hover: {\n                  enabled: false\n                }\n              }\n            },\n            noTooltip: true\n          });\n        }\n      }\n    });\n  });\n\n  // sort all data arrays of all series (Highcharts need data to be sorted by x)\n  series.forEach((ser)=> {\n    ser.data.sort(function compare(a, b) {\n      if (a.x < b.x) {\n        return -1;\n      }\n      if (a.x > b.x) {\n        return 1;\n      }\n      // a must be equal to b\n      return 0;\n    })\n  });\n\n  // split seriesData according to positive or negative stack\n  // important! The series.data need to be sorted already!\n  let [positiveSeries, negativeSeries] = splitSeriesData(series);\n\n  series = positiveSeries.concat(negativeSeries);\n\n  return series;\n}\n\nexport function findNullstellen(timeAxis, seriesData, xTolerance=0.001) {\n  // timeAxis: [..,2012,2013,2014,..]\n  // seriesData: [{id: \"\", data: [{y:2}, {y:3}, ..]}, ..]\n  // returns all Nullstellen of all series in seriesData merged into one object (intermediateTimes)\n  // ignores nullstellen that already land on a timeAxis-Stelle\n\n  let intermediateTimes = []; // [{x: 2012.4, xBefore: 2012, xAfter: 2013}]\n\n  let nullStellenBySeriesId = {}; // {\"someId\": [2012.4, 2015.6], ..}\n\n  seriesData.forEach((ser) => {\n\n    let activePart = \"positive\";\n    let valueBefore;\n\n    for(let i=0, len=timeAxis.length; i<len; i++) {\n      let x = timeAxis[i];\n      let value = ser.data[i].y;\n      let crossingFound;\n\n      // switch activePart on sign change\n      // zero values are ignored, because they are already part of the series\n      // and duplicate datapoints would lead to bugs in rendering\n      if(value < 0) {\n        if(activePart === \"positive\" && i > 0 && i < len) {\n          crossingFound = true;\n        }\n        activePart = \"negative\";\n      }\n      if(value > 0) {\n        if(activePart === \"negative\" && i > 0 && i < len) {\n          crossingFound = true;\n        }\n        activePart = \"positive\";\n      }\n\n      if(crossingFound) {\n\n        let xBefore = timeAxis[i-1];\n\n        let m = (value - valueBefore) / (x-xBefore); // x and xBefore are sometimes more than one unit apart!!\n        let x0 = -1*valueBefore/m + xBefore; //y1/m + x1\n\n        // don't add Nullstellen that already exist in the timeAxis, because duplicate datapoints lead to rendering errors\n        // also don't add datapoints if the nullStelle is already within tolerance to an already existing datapoint\n        if(timeAxis.indexOf(x0) >= 0 || x0 - xBefore < xTolerance || x - x0 < xTolerance) {\n          continue;\n        }\n\n        // setting toFixed() to 6 is important, if setting toFixed(2) sometimes it hits a round year\n        // which results in double entries in data, because parseFloat is ignoring zero decimals.\n        // parseFloat(2009.00) =>> 2009\n        // also if there are two equal nullstellen which might happen with toFixed(2)\n        // it also results in the error, that the highcharts updates are jumpy\n        // I haven't been able to fully track down the error, but using .toFixed(6)\n        // mitigates it and makes it much less likely to occur\n\n        intermediateTimes.push({\n          // x: nullStelle,\n          x: x0,\n          xBefore: xBefore,\n          xAfter: x\n        });\n        if(nullStellenBySeriesId[ser.id]) {\n          nullStellenBySeriesId[ser.id].push(x0);\n        } else {\n          nullStellenBySeriesId[ser.id] = [x0];\n        }\n\n      }\n      valueBefore = value;\n\n    }\n  });\n\n  return [intermediateTimes, nullStellenBySeriesId];\n}\n\n\nfunction linearInterpolatePoint(x, xBefore, xAfter, yBefore, yAfter) {\n  let y;\n\n  if(typeof xBefore !== 'undefined' && typeof xAfter !== 'undefined' && typeof yBefore !== 'undefined' && typeof yAfter !== 'undefined') {\n    let m = (yAfter - yBefore)/(xAfter-xBefore);\n    y = m*(x-xBefore) + yBefore;\n  }\n  // y can be undefined\n  return y;\n}\n\nfunction splitSeriesData(seriesData) {\n  // all series.data needs to be sorted already\n\n\n  // [{x:2015, y: 10},{x: 2015.5, y: 0},{x: 2016, y: 0},{x: 2017},{},{},{},{}]\n  //\n  // only y:0 are relevant\n  // when 0 is hit it gets written in the currentactivePart\n  // when a sign change happens to negative, the negative value gets written in the negativePart,\n  // but also the negativePart needs the 0 in it entered for the xBefore\n  //\n  // It always hits the 0, it never jumps directly to negative values!\n  // If it hits the 0 and the next value has a different sign, then the 0 gets written in both parts.\n\n\n  let positiveSeries = [];\n  let negativeSeries = [];\n\n  seriesData.forEach((series) => {\n\n    let data = series.data;\n    let positiveData = [];\n    let negativeData = [];\n\n    let activePart = positiveData;\n\n    for(let i=0, len=data.length; i<len; i++) {\n      let point = data[i];\n      let y = data[i].y;\n\n      if(y > 0) {\n        positiveData.push(point);\n        activePart = positiveData;\n      }\n      if(y < 0) {\n        negativeData.push(point);\n        activePart = negativeData;\n      }\n      if(y === 0) {\n        //ignore when first or last entry\n        if(i > 0 && i < len-1) {\n          let yBefore = data[i-1].y;\n          let yAfter= data[i+1].y;\n          if(Math.sign(yBefore) !== Math.sign(yAfter)) {\n            // push to both parts, when 0 is followed by a sign change\n            // but disable the tooltip for one\n            positiveData.push(point);\n            negativeData.push({\n              ...point, //spread operator\n              noTooltip: true\n            });\n          } else {\n            // if no sign change, just push to current active part\n            activePart.push(point);\n          }\n        } else {\n          // if 0 is first or last value it gets pushed to the current active part.\n          // activePart is positiveData for i==0\n          activePart.push(point);\n        }\n      }\n    }\n\n    positiveSeries.push({\n      name: series.name,\n      type: 'area',\n      id: series.id ? series.id : series.name,\n      data: positiveData,\n      stack: 'positive',\n      color: series.color ? series.color : undefined\n    });\n\n    negativeSeries.push({\n      name: series.name,\n      type: 'area',\n      linkedTo: series.id,\n      id: series.id ? series.id +'neg' : series.name +'neg', //id also necessary for negative series (for animated data update) I guess\n      data: negativeData,\n      stack: 'negative',\n      color: series.color ? series.color : undefined\n    });\n\n  });\n\n  return [positiveSeries, negativeSeries];\n}\n"],"mappings":"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"}]}