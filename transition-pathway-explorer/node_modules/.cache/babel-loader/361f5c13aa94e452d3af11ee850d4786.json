{"remainingRequest":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/babel-loader/lib/index.js!/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/eslint-loader/index.js??ref--13-0!/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/src/routeService.js","dependencies":[{"path":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/src/routeService.js","mtime":1707210098284},{"path":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/cache-loader/dist/cjs.js","mtime":1707234519865},{"path":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/babel-loader/lib/index.js","mtime":1707234519797},{"path":"/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/node_modules/eslint-loader/index.js","mtime":1707234519720}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport page from 'page';\nimport * as dataService from \"./dataService.js\";\nimport * as outputsService from \"./outputsService.js\";\nimport * as inputsService from \"./inputsService.js\";\nimport { appState } from \"./dataService.js\";\nvar shouldFetch = true; //default\n\nfunction compareQueryParameters(qs1, qs2) {\n  // compares the parameters of two query strings, doesn't directly compare the strings with each other,\n  // because the order of parameters might be different, which is irrellevant when one wants to know\n  // if the parameters match.\n  var params1 = new URLSearchParams(qs1);\n  var params2 = new URLSearchParams(qs2);\n  var matching = true; // params.keys() returns an iterator\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = params1.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var p = _step.value;\n\n      if (!params2.has(p) || params2.get(p) !== params1.get(p)) {\n        matching = false;\n        break;\n      }\n    } //need to be done for second paramset, because the params1 might be shorter than param2\n\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = params2.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _p = _step2.value;\n\n      // console.log('params2 p ', p);\n      if (!params1.has(_p) || params1.get(_p) !== params2.get(_p)) {\n        matching = false;\n        break;\n      }\n    } // console.log('matching ', matching);\n\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return matching;\n}\n\nexport function getURLParams(queryString, paramsToLookFor) {\n  //console.log(leverData.levers);\n  var results = {};\n  var urlParams = new URLSearchParams(queryString);\n  paramsToLookFor.forEach(function (name) {\n    var param = urlParams.get(name);\n\n    if (param) {\n      results[name] = param;\n    }\n  });\n  return results;\n}\nexport function initRoutes() {\n  /*set up routes*/\n  page('/', routeHome); // page('/welcome', routeWelcome);\n\n  page('/intro', routeIntro); // page('/intro/:screen', routeIntroScreen);\n\n  page('/budget', routeBudget);\n  page('/legal', routeLegal);\n  page('/app', routeCalculator);\n  page('/app/:tab', routeTab);\n  page('/app/:tab/:subtab', routeSubtab);\n  page('*', routeNotFound); //activating\n\n  page();\n} // export function toggleFetching(_shouldFetch) {\n//   shouldFetch = _shouldFetch;\n// }\n\nvar routeHome = function routeHome() {\n  page.redirect('/intro');\n};\n\nvar routeCalculator = function routeCalculator() {\n  // redirect to first subtab\n  var tabIndex = 0;\n  var routeOfFirstTab = outputsService.tabRoutes[tabIndex].route;\n  var routeOfFirstSubtab = outputsService.tabRoutes[tabIndex][0].route;\n\n  if (routeOfFirstSubtab) {\n    page.redirect('/app/' + routeOfFirstTab + '/' + routeOfFirstSubtab);\n  }\n};\n\nvar routeIntro = function routeIntro() {\n  appState.mode = 'intro';\n};\n\nvar routeBudget = function routeBudget() {\n  appState.mode = 'target';\n  appState.menuOpen = false;\n};\n\nvar routeLegal = function routeLegal() {\n  //console.log('routeLegal');\n  appState.mode = 'legal';\n  appState.menuOpen = false;\n};\n\nvar routeTab = function routeTab(context) {\n  //redirects to the first subtab, defaults to the first tab if given tab from the URL doesn't exist\n  //find the name of the first subtab and redirect to that route\n  var tabname = context.params.tab; //load first tab by default, if tabname is not found (bad url)\n\n  var tabIndex = outputsService.routes[tabname] ? outputsService.routes[tabname].index : 0;\n  var routeOfTab = outputsService.tabRoutes[tabIndex].route;\n  var routeOfFirstSubtab = outputsService.tabRoutes[tabIndex][0].route;\n\n  if (routeOfFirstSubtab) {\n    page.redirect('/app/' + routeOfTab + '/' + routeOfFirstSubtab);\n  }\n};\n\nvar routeSubtab = function routeSubtab(context) {\n  // during routing:\n  // 1. appState is set according to url-parameters\n  //    during that step the app-state is adapted if the parameters are invalid\n  //    or if levers are eu-only-values\n  // 2. at the end of the route process the querystring gets updated to the actual app-state\n  // window.location.search is empty in some cases, use context.querystring instead\n  // setTimeout(()=> {\n  console.log('routeSubtab ', appState); //check context, correct to default values for routeOfTab and routeOfSubtab if necessary\n\n  var tabname = context.params.tab; //load first tab by default, if tabname is not found (bad url)\n\n  var tabIndex = outputsService.routes[tabname] ? outputsService.routes[tabname].index : 0;\n  var routeOfTab = outputsService.tabRoutes[tabIndex].route;\n  var subtabname = context.params.subtab; //load first subtab by default, if subtabname is not found (bad url)\n\n  var subtabIndex = outputsService.routes[routeOfTab][subtabname] ? outputsService.routes[routeOfTab][subtabname].index : 0; // let routeOfSubtab = outputsService.tabRoutes[tabIndex][subtabIndex].route;\n\n  appState.mode = 'main';\n  appState.menuOpen = false; // compare current route params with params of old state:\n  // this is only necessary in routeSubtab\n\n  var routeQuerystring = context.querystring; //works\n\n  var appStateQuerystring = appState.mainScreenRouteString.indexOf('?') > -1 ? appState.mainScreenRouteString.substring(appState.mainScreenRouteString.indexOf('?')) : \"\"; // paramsMatch is also true if both queryStrings are empty\n\n  var paramsMatch = compareQueryParameters(routeQuerystring, appStateQuerystring); //check tab and subtab from URL against those in appState\n\n  var tabMatches; //subtab doesn't matter, a change in a subtab doesn't trigger a fetch\n\n  if (appState.activeTab !== null && appState.activeTab === tabIndex) {\n    tabMatches = true;\n  } // If the old and new querystrings didn't match, set all parameters again, even if only one might be different\n  // resetting the whole state instead of changing it is a bit less efficient, but safer and less prone to bugs\n  //--> disadvantage: prefetching a subtab is impossible, because it would start a new fetch here, because the URLs didn't match\n  //urlParameters are needed regardless of paramsMatch\n\n\n  var urlParameters = getURLParams(routeQuerystring, ['levers', 'other', 'country']); // when navigating from main-screen to budget and back to mainscreen,\n  // urlParameters exists but the params already match (Object.keys(urlParameters).length > 0, paramsMatch == true)\n  // --> in that case nothing happens\n  // if there are params and they don't match with the appState\n\n  if (Object.keys(urlParameters).length && !paramsMatch) {\n    // setInputsFromURLParameters() checks if parameters are valid and applies fallback settings if not\n    inputsService.setInputsFromURLParameters(urlParameters.levers, urlParameters.other, urlParameters.country);\n  } else if (!Object.keys(urlParameters).length) {\n    // load the first example pathway if there are no parameters set\n    inputsService.setExamplePathway(0);\n  }\n\n  outputsService.selectTab(tabIndex, subtabIndex, false); // Automatic zoom into a country is deactivated for now,\n  // because even when just clicking away from the MainScreen and back to it, it would zoom into a country\n  // if a country is zoomed into would need to be a URL parameter to avoid that case\n  // if(urlParameters.other && urlParameters.country) {\n  //   outputsService.setCountryZoom(1); //zoom into that country, if subtab-component supports it\n  // }\n  // checkIfLeversMatchExamplePathway also sets appState.pathwayIndex if any was found and that sets the pathway select-input\n\n  var matchesWithExamplePathway;\n  matchesWithExamplePathway = inputsService.checkIfLeversMatchExamplePathway();\n\n  if (appState.onlyExamplePathwayRoutes && !matchesWithExamplePathway) {\n    // if in examplePathwaysOnly-mode and the user changed the url to a\n    // non-valid pathway (non-examplePathway), then redirect to home-route\n    // resetting to the first examplePathway is difficult, because also\n    // any single-country-levers-settings would need to get corrected\n    // resetting all state is tedious for this edge case, so just trigger a hard reload:\n    document.location.replace(document.location.origin); // page.redirect('/app'); /doesn't work because old appState will still be present\n\n    return; //not necessary actually\n  } // important: update the appState.mainScreenRouteString (after setting all state inside the app)\n  // create the routeString from app data, not from window.location.pathname,\n  // because the URL might be bad and the tabs might have been corrected to valid ones\n\n\n  var routeString = dataService.createRouteString();\n  appState.mainScreenRouteString = routeString; // console.log('routeString ', routeString)\n  // DONT call history.pushState, use history.replaceState to correct or complete the URL (matching it against the appState)\n  // Always work with full a URL that reflects the appState's get parameters, this is important when working with the\n  // browser-history, so that when a user clicks back or forward, the URL always contains all necessary information to\n  // rebuild the appState. Additional info that is not stored in the URL can optionally be stored in the history's stateObj\n  // (like appState.countryZoom for instance (this is not implemented))\n\n  history.replaceState({\n    path: appState.mainScreenRouteString\n  }, null, appState.mainScreenRouteString); // history.pushState({path: appState.mainScreenRouteString}, null, appState.mainScreenRouteString);\n  // console.log('routeSubtab ', paramsMatch, tabMatches);\n\n  if ((!paramsMatch || !tabMatches) && shouldFetch) {\n    console.log('routeSubtab fetching'); // reset user actions before fetch (otherwise it would zoom into a selected country by default)\n\n    appState.userAction = [];\n    dataService.fetchData();\n  } // },0);\n\n};\n\nvar routeNotFound = function routeNotFound() {\n  console.log('routeNotFound');\n  page.redirect('/');\n};",{"version":3,"sources":["/Users/paruta/2050-Calculators/EUcalc/paris-tool/transition-pathway-explorer/src/routeService.js"],"names":["page","dataService","outputsService","inputsService","appState","shouldFetch","compareQueryParameters","qs1","qs2","params1","URLSearchParams","params2","matching","keys","p","has","get","getURLParams","queryString","paramsToLookFor","results","urlParams","forEach","name","param","initRoutes","routeHome","routeIntro","routeBudget","routeLegal","routeCalculator","routeTab","routeSubtab","routeNotFound","redirect","tabIndex","routeOfFirstTab","tabRoutes","route","routeOfFirstSubtab","mode","menuOpen","context","tabname","params","tab","routes","index","routeOfTab","console","log","subtabname","subtab","subtabIndex","routeQuerystring","querystring","appStateQuerystring","mainScreenRouteString","indexOf","substring","paramsMatch","tabMatches","activeTab","urlParameters","Object","length","setInputsFromURLParameters","levers","other","country","setExamplePathway","selectTab","matchesWithExamplePathway","checkIfLeversMatchExamplePathway","onlyExamplePathwayRoutes","document","location","replace","origin","routeString","createRouteString","history","replaceState","path","userAction","fetchData"],"mappings":"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","sourcesContent":["import page from 'page';\n\nimport * as dataService from './dataService.js';\nimport * as outputsService from './outputsService.js';\nimport * as inputsService from './inputsService.js';\n\nimport {appState} from './dataService.js';\n\nvar shouldFetch = true; //default\n\nfunction compareQueryParameters(qs1,qs2) {\n  // compares the parameters of two query strings, doesn't directly compare the strings with each other,\n  // because the order of parameters might be different, which is irrellevant when one wants to know\n  // if the parameters match.\n\n  let params1 = new URLSearchParams(qs1);\n  let params2 = new URLSearchParams(qs2);\n\n  let matching = true;\n\n  // params.keys() returns an iterator\n  for(let p of params1.keys()) {\n    if(!params2.has(p) || params2.get(p) !== params1.get(p)) {\n      matching = false;\n      break;\n    }\n  }\n\n  //need to be done for second paramset, because the params1 might be shorter than param2\n  for(let p of params2.keys()) {\n    // console.log('params2 p ', p);\n    if(!params1.has(p) || params1.get(p) !== params2.get(p)) {\n      matching = false;\n      break;\n    }\n  }\n\n  // console.log('matching ', matching);\n  return matching;\n}\n\n\nexport function getURLParams(queryString, paramsToLookFor) {\n  //console.log(leverData.levers);\n  var results = {};\n\n  const urlParams = new URLSearchParams(queryString);\n  paramsToLookFor.forEach((name)=> {\n    let param = urlParams.get(name);\n    if(param) {\n      results[name] = param;\n    }\n  });\n\n  return results;\n}\n\nexport function initRoutes() {\n  /*set up routes*/\n  page('/', routeHome);\n  // page('/welcome', routeWelcome);\n  page('/intro', routeIntro);\n  // page('/intro/:screen', routeIntroScreen);\n  page('/budget', routeBudget);\n  page('/legal', routeLegal);\n  page('/app', routeCalculator);\n  page('/app/:tab', routeTab);\n  page('/app/:tab/:subtab', routeSubtab);\n  page('*', routeNotFound);\n\n  //activating\n  page();\n}\n\n// export function toggleFetching(_shouldFetch) {\n//   shouldFetch = _shouldFetch;\n// }\n\n\nvar routeHome = function() {\n  page.redirect('/intro');\n};\n\nvar routeCalculator = function() {\n  // redirect to first subtab\n  let tabIndex = 0;\n  let routeOfFirstTab = outputsService.tabRoutes[tabIndex].route;\n\n  let routeOfFirstSubtab = outputsService.tabRoutes[tabIndex][0].route\n\n  if(routeOfFirstSubtab) {\n    page.redirect('/app/'+routeOfFirstTab+'/'+routeOfFirstSubtab);\n  }\n};\n\nvar routeIntro = function() {\n  appState.mode = 'intro';\n};\n\nvar routeBudget = function() {\n  appState.mode = 'target';\n  appState.menuOpen = false;\n};\n\nvar routeLegal = function() {\n  //console.log('routeLegal');\n  appState.mode = 'legal';\n  appState.menuOpen = false;\n};\n\nvar routeTab = function(context) {\n\n  //redirects to the first subtab, defaults to the first tab if given tab from the URL doesn't exist\n  //find the name of the first subtab and redirect to that route\n  let tabname = context.params.tab;\n\n  //load first tab by default, if tabname is not found (bad url)\n  let tabIndex = outputsService.routes[tabname] ? outputsService.routes[tabname].index : 0;\n  let routeOfTab = outputsService.tabRoutes[tabIndex].route;\n\n\n  let routeOfFirstSubtab = outputsService.tabRoutes[tabIndex][0].route\n\n  if(routeOfFirstSubtab) {\n    page.redirect('/app/'+routeOfTab+'/'+routeOfFirstSubtab);\n  }\n\n};\n\nvar routeSubtab = function(context) {\n  // during routing:\n  // 1. appState is set according to url-parameters\n  //    during that step the app-state is adapted if the parameters are invalid\n  //    or if levers are eu-only-values\n  // 2. at the end of the route process the querystring gets updated to the actual app-state\n\n  // window.location.search is empty in some cases, use context.querystring instead\n\n  // setTimeout(()=> {\n    console.log('routeSubtab ', appState);\n\n    //check context, correct to default values for routeOfTab and routeOfSubtab if necessary\n    let tabname = context.params.tab;\n    //load first tab by default, if tabname is not found (bad url)\n    let tabIndex = outputsService.routes[tabname] ? outputsService.routes[tabname].index : 0;\n    let routeOfTab = outputsService.tabRoutes[tabIndex].route;\n\n    let subtabname = context.params.subtab;\n    //load first subtab by default, if subtabname is not found (bad url)\n    let subtabIndex = outputsService.routes[routeOfTab][subtabname] ? outputsService.routes[routeOfTab][subtabname].index : 0;\n    // let routeOfSubtab = outputsService.tabRoutes[tabIndex][subtabIndex].route;\n\n    appState.mode = 'main';\n    appState.menuOpen = false;\n\n    // compare current route params with params of old state:\n    // this is only necessary in routeSubtab\n    let routeQuerystring = context.querystring; //works\n    let appStateQuerystring = appState.mainScreenRouteString.indexOf('?') > -1 ? appState.mainScreenRouteString.substring(appState.mainScreenRouteString.indexOf('?')) : \"\";\n\n    // paramsMatch is also true if both queryStrings are empty\n    let paramsMatch = compareQueryParameters(routeQuerystring, appStateQuerystring);\n\n    //check tab and subtab from URL against those in appState\n    let tabMatches; //subtab doesn't matter, a change in a subtab doesn't trigger a fetch\n    if(appState.activeTab !== null && appState.activeTab === tabIndex) {\n      tabMatches = true;\n    }\n\n    // If the old and new querystrings didn't match, set all parameters again, even if only one might be different\n    // resetting the whole state instead of changing it is a bit less efficient, but safer and less prone to bugs\n    //--> disadvantage: prefetching a subtab is impossible, because it would start a new fetch here, because the URLs didn't match\n\n    //urlParameters are needed regardless of paramsMatch\n    let urlParameters = getURLParams(routeQuerystring, ['levers', 'other', 'country']);\n\n    // when navigating from main-screen to budget and back to mainscreen,\n    // urlParameters exists but the params already match (Object.keys(urlParameters).length > 0, paramsMatch == true)\n    // --> in that case nothing happens\n    // if there are params and they don't match with the appState\n    if(Object.keys(urlParameters).length && !paramsMatch) {\n\n      // setInputsFromURLParameters() checks if parameters are valid and applies fallback settings if not\n      inputsService.setInputsFromURLParameters(urlParameters.levers, urlParameters.other, urlParameters.country);\n\n    } else if(!Object.keys(urlParameters).length) {\n      // load the first example pathway if there are no parameters set\n      inputsService.setExamplePathway(0);\n    }\n\n    outputsService.selectTab(tabIndex,subtabIndex,false);\n\n    // Automatic zoom into a country is deactivated for now,\n    // because even when just clicking away from the MainScreen and back to it, it would zoom into a country\n    // if a country is zoomed into would need to be a URL parameter to avoid that case\n    // if(urlParameters.other && urlParameters.country) {\n    //   outputsService.setCountryZoom(1); //zoom into that country, if subtab-component supports it\n    // }\n\n    // checkIfLeversMatchExamplePathway also sets appState.pathwayIndex if any was found and that sets the pathway select-input\n    let matchesWithExamplePathway;\n    matchesWithExamplePathway = inputsService.checkIfLeversMatchExamplePathway();\n\n    if(appState.onlyExamplePathwayRoutes && !matchesWithExamplePathway) {\n      // if in examplePathwaysOnly-mode and the user changed the url to a\n      // non-valid pathway (non-examplePathway), then redirect to home-route\n      // resetting to the first examplePathway is difficult, because also\n      // any single-country-levers-settings would need to get corrected\n      // resetting all state is tedious for this edge case, so just trigger a hard reload:\n      document.location.replace(document.location.origin);\n      // page.redirect('/app'); /doesn't work because old appState will still be present\n      return; //not necessary actually\n    }\n\n    // important: update the appState.mainScreenRouteString (after setting all state inside the app)\n    // create the routeString from app data, not from window.location.pathname,\n    // because the URL might be bad and the tabs might have been corrected to valid ones\n    let routeString = dataService.createRouteString();\n\n    appState.mainScreenRouteString = routeString;\n    // console.log('routeString ', routeString)\n\n    // DONT call history.pushState, use history.replaceState to correct or complete the URL (matching it against the appState)\n    // Always work with full a URL that reflects the appState's get parameters, this is important when working with the\n    // browser-history, so that when a user clicks back or forward, the URL always contains all necessary information to\n    // rebuild the appState. Additional info that is not stored in the URL can optionally be stored in the history's stateObj\n    // (like appState.countryZoom for instance (this is not implemented))\n    history.replaceState({path: appState.mainScreenRouteString}, null, appState.mainScreenRouteString);\n    // history.pushState({path: appState.mainScreenRouteString}, null, appState.mainScreenRouteString);\n\n    // console.log('routeSubtab ', paramsMatch, tabMatches);\n    if((!paramsMatch || !tabMatches) && shouldFetch) {\n      console.log('routeSubtab fetching');\n\n      // reset user actions before fetch (otherwise it would zoom into a selected country by default)\n      appState.userAction = [];\n      dataService.fetchData();\n    }\n  // },0);\n};\n\nvar routeNotFound = function() {\n  console.log('routeNotFound');\n  page.redirect('/');\n}\n"]}]}